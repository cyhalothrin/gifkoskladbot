package extractor

// Code generated by http://github.com/gojuno/minimock (dev). DO NOT EDIT.

//go:generate minimock -i github.com/cyhalothrin/gifkoskladbot/favchannel/extractor.storage -o ./favchannel/extractor/storage_mock_test.go

import (
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	"github.com/gojuno/minimock/v3"
)

// StorageMock implements storage
type StorageMock struct {
	t minimock.Tester

	funcGetFavChannelLastForwardedMessageIDWithoutCaption          func() (i1 int64)
	inspectFuncGetFavChannelLastForwardedMessageIDWithoutCaption   func()
	afterGetFavChannelLastForwardedMessageIDWithoutCaptionCounter  uint64
	beforeGetFavChannelLastForwardedMessageIDWithoutCaptionCounter uint64
	GetFavChannelLastForwardedMessageIDWithoutCaptionMock          mStorageMockGetFavChannelLastForwardedMessageIDWithoutCaption

	funcGetTags          func() (sa1 []string)
	inspectFuncGetTags   func()
	afterGetTagsCounter  uint64
	beforeGetTagsCounter uint64
	GetTagsMock          mStorageMockGetTags

	funcSetFavChannelLastForwardedMessageIDWithoutCaption          func(i1 int64)
	inspectFuncSetFavChannelLastForwardedMessageIDWithoutCaption   func(i1 int64)
	afterSetFavChannelLastForwardedMessageIDWithoutCaptionCounter  uint64
	beforeSetFavChannelLastForwardedMessageIDWithoutCaptionCounter uint64
	SetFavChannelLastForwardedMessageIDWithoutCaptionMock          mStorageMockSetFavChannelLastForwardedMessageIDWithoutCaption

	funcSetTags          func(sa1 []string)
	inspectFuncSetTags   func(sa1 []string)
	afterSetTagsCounter  uint64
	beforeSetTagsCounter uint64
	SetTagsMock          mStorageMockSetTags
}

// NewStorageMock returns a mock for storage
func NewStorageMock(t minimock.Tester) *StorageMock {
	m := &StorageMock{t: t}
	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.GetFavChannelLastForwardedMessageIDWithoutCaptionMock = mStorageMockGetFavChannelLastForwardedMessageIDWithoutCaption{mock: m}

	m.GetTagsMock = mStorageMockGetTags{mock: m}

	m.SetFavChannelLastForwardedMessageIDWithoutCaptionMock = mStorageMockSetFavChannelLastForwardedMessageIDWithoutCaption{mock: m}
	m.SetFavChannelLastForwardedMessageIDWithoutCaptionMock.callArgs = []*StorageMockSetFavChannelLastForwardedMessageIDWithoutCaptionParams{}

	m.SetTagsMock = mStorageMockSetTags{mock: m}
	m.SetTagsMock.callArgs = []*StorageMockSetTagsParams{}

	return m
}

type mStorageMockGetFavChannelLastForwardedMessageIDWithoutCaption struct {
	mock               *StorageMock
	defaultExpectation *StorageMockGetFavChannelLastForwardedMessageIDWithoutCaptionExpectation
	expectations       []*StorageMockGetFavChannelLastForwardedMessageIDWithoutCaptionExpectation
}

// StorageMockGetFavChannelLastForwardedMessageIDWithoutCaptionExpectation specifies expectation struct of the storage.GetFavChannelLastForwardedMessageIDWithoutCaption
type StorageMockGetFavChannelLastForwardedMessageIDWithoutCaptionExpectation struct {
	mock *StorageMock

	results *StorageMockGetFavChannelLastForwardedMessageIDWithoutCaptionResults
	Counter uint64
}

// StorageMockGetFavChannelLastForwardedMessageIDWithoutCaptionResults contains results of the storage.GetFavChannelLastForwardedMessageIDWithoutCaption
type StorageMockGetFavChannelLastForwardedMessageIDWithoutCaptionResults struct {
	i1 int64
}

// Expect sets up expected params for storage.GetFavChannelLastForwardedMessageIDWithoutCaption
func (mmGetFavChannelLastForwardedMessageIDWithoutCaption *mStorageMockGetFavChannelLastForwardedMessageIDWithoutCaption) Expect() *mStorageMockGetFavChannelLastForwardedMessageIDWithoutCaption {
	if mmGetFavChannelLastForwardedMessageIDWithoutCaption.mock.funcGetFavChannelLastForwardedMessageIDWithoutCaption != nil {
		mmGetFavChannelLastForwardedMessageIDWithoutCaption.mock.t.Fatalf("StorageMock.GetFavChannelLastForwardedMessageIDWithoutCaption mock is already set by Set")
	}

	if mmGetFavChannelLastForwardedMessageIDWithoutCaption.defaultExpectation == nil {
		mmGetFavChannelLastForwardedMessageIDWithoutCaption.defaultExpectation = &StorageMockGetFavChannelLastForwardedMessageIDWithoutCaptionExpectation{}
	}

	return mmGetFavChannelLastForwardedMessageIDWithoutCaption
}

// Inspect accepts an inspector function that has same arguments as the storage.GetFavChannelLastForwardedMessageIDWithoutCaption
func (mmGetFavChannelLastForwardedMessageIDWithoutCaption *mStorageMockGetFavChannelLastForwardedMessageIDWithoutCaption) Inspect(f func()) *mStorageMockGetFavChannelLastForwardedMessageIDWithoutCaption {
	if mmGetFavChannelLastForwardedMessageIDWithoutCaption.mock.inspectFuncGetFavChannelLastForwardedMessageIDWithoutCaption != nil {
		mmGetFavChannelLastForwardedMessageIDWithoutCaption.mock.t.Fatalf("Inspect function is already set for StorageMock.GetFavChannelLastForwardedMessageIDWithoutCaption")
	}

	mmGetFavChannelLastForwardedMessageIDWithoutCaption.mock.inspectFuncGetFavChannelLastForwardedMessageIDWithoutCaption = f

	return mmGetFavChannelLastForwardedMessageIDWithoutCaption
}

// Return sets up results that will be returned by storage.GetFavChannelLastForwardedMessageIDWithoutCaption
func (mmGetFavChannelLastForwardedMessageIDWithoutCaption *mStorageMockGetFavChannelLastForwardedMessageIDWithoutCaption) Return(i1 int64) *StorageMock {
	if mmGetFavChannelLastForwardedMessageIDWithoutCaption.mock.funcGetFavChannelLastForwardedMessageIDWithoutCaption != nil {
		mmGetFavChannelLastForwardedMessageIDWithoutCaption.mock.t.Fatalf("StorageMock.GetFavChannelLastForwardedMessageIDWithoutCaption mock is already set by Set")
	}

	if mmGetFavChannelLastForwardedMessageIDWithoutCaption.defaultExpectation == nil {
		mmGetFavChannelLastForwardedMessageIDWithoutCaption.defaultExpectation = &StorageMockGetFavChannelLastForwardedMessageIDWithoutCaptionExpectation{mock: mmGetFavChannelLastForwardedMessageIDWithoutCaption.mock}
	}
	mmGetFavChannelLastForwardedMessageIDWithoutCaption.defaultExpectation.results = &StorageMockGetFavChannelLastForwardedMessageIDWithoutCaptionResults{i1}
	return mmGetFavChannelLastForwardedMessageIDWithoutCaption.mock
}

//Set uses given function f to mock the storage.GetFavChannelLastForwardedMessageIDWithoutCaption method
func (mmGetFavChannelLastForwardedMessageIDWithoutCaption *mStorageMockGetFavChannelLastForwardedMessageIDWithoutCaption) Set(f func() (i1 int64)) *StorageMock {
	if mmGetFavChannelLastForwardedMessageIDWithoutCaption.defaultExpectation != nil {
		mmGetFavChannelLastForwardedMessageIDWithoutCaption.mock.t.Fatalf("Default expectation is already set for the storage.GetFavChannelLastForwardedMessageIDWithoutCaption method")
	}

	if len(mmGetFavChannelLastForwardedMessageIDWithoutCaption.expectations) > 0 {
		mmGetFavChannelLastForwardedMessageIDWithoutCaption.mock.t.Fatalf("Some expectations are already set for the storage.GetFavChannelLastForwardedMessageIDWithoutCaption method")
	}

	mmGetFavChannelLastForwardedMessageIDWithoutCaption.mock.funcGetFavChannelLastForwardedMessageIDWithoutCaption = f
	return mmGetFavChannelLastForwardedMessageIDWithoutCaption.mock
}

// GetFavChannelLastForwardedMessageIDWithoutCaption implements storage
func (mmGetFavChannelLastForwardedMessageIDWithoutCaption *StorageMock) GetFavChannelLastForwardedMessageIDWithoutCaption() (i1 int64) {
	mm_atomic.AddUint64(&mmGetFavChannelLastForwardedMessageIDWithoutCaption.beforeGetFavChannelLastForwardedMessageIDWithoutCaptionCounter, 1)
	defer mm_atomic.AddUint64(&mmGetFavChannelLastForwardedMessageIDWithoutCaption.afterGetFavChannelLastForwardedMessageIDWithoutCaptionCounter, 1)

	if mmGetFavChannelLastForwardedMessageIDWithoutCaption.inspectFuncGetFavChannelLastForwardedMessageIDWithoutCaption != nil {
		mmGetFavChannelLastForwardedMessageIDWithoutCaption.inspectFuncGetFavChannelLastForwardedMessageIDWithoutCaption()
	}

	if mmGetFavChannelLastForwardedMessageIDWithoutCaption.GetFavChannelLastForwardedMessageIDWithoutCaptionMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetFavChannelLastForwardedMessageIDWithoutCaption.GetFavChannelLastForwardedMessageIDWithoutCaptionMock.defaultExpectation.Counter, 1)

		mm_results := mmGetFavChannelLastForwardedMessageIDWithoutCaption.GetFavChannelLastForwardedMessageIDWithoutCaptionMock.defaultExpectation.results
		if mm_results == nil {
			mmGetFavChannelLastForwardedMessageIDWithoutCaption.t.Fatal("No results are set for the StorageMock.GetFavChannelLastForwardedMessageIDWithoutCaption")
		}
		return (*mm_results).i1
	}
	if mmGetFavChannelLastForwardedMessageIDWithoutCaption.funcGetFavChannelLastForwardedMessageIDWithoutCaption != nil {
		return mmGetFavChannelLastForwardedMessageIDWithoutCaption.funcGetFavChannelLastForwardedMessageIDWithoutCaption()
	}
	mmGetFavChannelLastForwardedMessageIDWithoutCaption.t.Fatalf("Unexpected call to StorageMock.GetFavChannelLastForwardedMessageIDWithoutCaption.")
	return
}

// GetFavChannelLastForwardedMessageIDWithoutCaptionAfterCounter returns a count of finished StorageMock.GetFavChannelLastForwardedMessageIDWithoutCaption invocations
func (mmGetFavChannelLastForwardedMessageIDWithoutCaption *StorageMock) GetFavChannelLastForwardedMessageIDWithoutCaptionAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetFavChannelLastForwardedMessageIDWithoutCaption.afterGetFavChannelLastForwardedMessageIDWithoutCaptionCounter)
}

// GetFavChannelLastForwardedMessageIDWithoutCaptionBeforeCounter returns a count of StorageMock.GetFavChannelLastForwardedMessageIDWithoutCaption invocations
func (mmGetFavChannelLastForwardedMessageIDWithoutCaption *StorageMock) GetFavChannelLastForwardedMessageIDWithoutCaptionBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetFavChannelLastForwardedMessageIDWithoutCaption.beforeGetFavChannelLastForwardedMessageIDWithoutCaptionCounter)
}

// MinimockGetFavChannelLastForwardedMessageIDWithoutCaptionDone returns true if the count of the GetFavChannelLastForwardedMessageIDWithoutCaption invocations corresponds
// the number of defined expectations
func (m *StorageMock) MinimockGetFavChannelLastForwardedMessageIDWithoutCaptionDone() bool {
	for _, e := range m.GetFavChannelLastForwardedMessageIDWithoutCaptionMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetFavChannelLastForwardedMessageIDWithoutCaptionMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetFavChannelLastForwardedMessageIDWithoutCaptionCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetFavChannelLastForwardedMessageIDWithoutCaption != nil && mm_atomic.LoadUint64(&m.afterGetFavChannelLastForwardedMessageIDWithoutCaptionCounter) < 1 {
		return false
	}
	return true
}

// MinimockGetFavChannelLastForwardedMessageIDWithoutCaptionInspect logs each unmet expectation
func (m *StorageMock) MinimockGetFavChannelLastForwardedMessageIDWithoutCaptionInspect() {
	for _, e := range m.GetFavChannelLastForwardedMessageIDWithoutCaptionMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to StorageMock.GetFavChannelLastForwardedMessageIDWithoutCaption")
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetFavChannelLastForwardedMessageIDWithoutCaptionMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetFavChannelLastForwardedMessageIDWithoutCaptionCounter) < 1 {
		m.t.Error("Expected call to StorageMock.GetFavChannelLastForwardedMessageIDWithoutCaption")
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetFavChannelLastForwardedMessageIDWithoutCaption != nil && mm_atomic.LoadUint64(&m.afterGetFavChannelLastForwardedMessageIDWithoutCaptionCounter) < 1 {
		m.t.Error("Expected call to StorageMock.GetFavChannelLastForwardedMessageIDWithoutCaption")
	}
}

type mStorageMockGetTags struct {
	mock               *StorageMock
	defaultExpectation *StorageMockGetTagsExpectation
	expectations       []*StorageMockGetTagsExpectation
}

// StorageMockGetTagsExpectation specifies expectation struct of the storage.GetTags
type StorageMockGetTagsExpectation struct {
	mock *StorageMock

	results *StorageMockGetTagsResults
	Counter uint64
}

// StorageMockGetTagsResults contains results of the storage.GetTags
type StorageMockGetTagsResults struct {
	sa1 []string
}

// Expect sets up expected params for storage.GetTags
func (mmGetTags *mStorageMockGetTags) Expect() *mStorageMockGetTags {
	if mmGetTags.mock.funcGetTags != nil {
		mmGetTags.mock.t.Fatalf("StorageMock.GetTags mock is already set by Set")
	}

	if mmGetTags.defaultExpectation == nil {
		mmGetTags.defaultExpectation = &StorageMockGetTagsExpectation{}
	}

	return mmGetTags
}

// Inspect accepts an inspector function that has same arguments as the storage.GetTags
func (mmGetTags *mStorageMockGetTags) Inspect(f func()) *mStorageMockGetTags {
	if mmGetTags.mock.inspectFuncGetTags != nil {
		mmGetTags.mock.t.Fatalf("Inspect function is already set for StorageMock.GetTags")
	}

	mmGetTags.mock.inspectFuncGetTags = f

	return mmGetTags
}

// Return sets up results that will be returned by storage.GetTags
func (mmGetTags *mStorageMockGetTags) Return(sa1 []string) *StorageMock {
	if mmGetTags.mock.funcGetTags != nil {
		mmGetTags.mock.t.Fatalf("StorageMock.GetTags mock is already set by Set")
	}

	if mmGetTags.defaultExpectation == nil {
		mmGetTags.defaultExpectation = &StorageMockGetTagsExpectation{mock: mmGetTags.mock}
	}
	mmGetTags.defaultExpectation.results = &StorageMockGetTagsResults{sa1}
	return mmGetTags.mock
}

//Set uses given function f to mock the storage.GetTags method
func (mmGetTags *mStorageMockGetTags) Set(f func() (sa1 []string)) *StorageMock {
	if mmGetTags.defaultExpectation != nil {
		mmGetTags.mock.t.Fatalf("Default expectation is already set for the storage.GetTags method")
	}

	if len(mmGetTags.expectations) > 0 {
		mmGetTags.mock.t.Fatalf("Some expectations are already set for the storage.GetTags method")
	}

	mmGetTags.mock.funcGetTags = f
	return mmGetTags.mock
}

// GetTags implements storage
func (mmGetTags *StorageMock) GetTags() (sa1 []string) {
	mm_atomic.AddUint64(&mmGetTags.beforeGetTagsCounter, 1)
	defer mm_atomic.AddUint64(&mmGetTags.afterGetTagsCounter, 1)

	if mmGetTags.inspectFuncGetTags != nil {
		mmGetTags.inspectFuncGetTags()
	}

	if mmGetTags.GetTagsMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetTags.GetTagsMock.defaultExpectation.Counter, 1)

		mm_results := mmGetTags.GetTagsMock.defaultExpectation.results
		if mm_results == nil {
			mmGetTags.t.Fatal("No results are set for the StorageMock.GetTags")
		}
		return (*mm_results).sa1
	}
	if mmGetTags.funcGetTags != nil {
		return mmGetTags.funcGetTags()
	}
	mmGetTags.t.Fatalf("Unexpected call to StorageMock.GetTags.")
	return
}

// GetTagsAfterCounter returns a count of finished StorageMock.GetTags invocations
func (mmGetTags *StorageMock) GetTagsAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetTags.afterGetTagsCounter)
}

// GetTagsBeforeCounter returns a count of StorageMock.GetTags invocations
func (mmGetTags *StorageMock) GetTagsBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetTags.beforeGetTagsCounter)
}

// MinimockGetTagsDone returns true if the count of the GetTags invocations corresponds
// the number of defined expectations
func (m *StorageMock) MinimockGetTagsDone() bool {
	for _, e := range m.GetTagsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetTagsMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetTagsCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetTags != nil && mm_atomic.LoadUint64(&m.afterGetTagsCounter) < 1 {
		return false
	}
	return true
}

// MinimockGetTagsInspect logs each unmet expectation
func (m *StorageMock) MinimockGetTagsInspect() {
	for _, e := range m.GetTagsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to StorageMock.GetTags")
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetTagsMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetTagsCounter) < 1 {
		m.t.Error("Expected call to StorageMock.GetTags")
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetTags != nil && mm_atomic.LoadUint64(&m.afterGetTagsCounter) < 1 {
		m.t.Error("Expected call to StorageMock.GetTags")
	}
}

type mStorageMockSetFavChannelLastForwardedMessageIDWithoutCaption struct {
	mock               *StorageMock
	defaultExpectation *StorageMockSetFavChannelLastForwardedMessageIDWithoutCaptionExpectation
	expectations       []*StorageMockSetFavChannelLastForwardedMessageIDWithoutCaptionExpectation

	callArgs []*StorageMockSetFavChannelLastForwardedMessageIDWithoutCaptionParams
	mutex    sync.RWMutex
}

// StorageMockSetFavChannelLastForwardedMessageIDWithoutCaptionExpectation specifies expectation struct of the storage.SetFavChannelLastForwardedMessageIDWithoutCaption
type StorageMockSetFavChannelLastForwardedMessageIDWithoutCaptionExpectation struct {
	mock   *StorageMock
	params *StorageMockSetFavChannelLastForwardedMessageIDWithoutCaptionParams

	Counter uint64
}

// StorageMockSetFavChannelLastForwardedMessageIDWithoutCaptionParams contains parameters of the storage.SetFavChannelLastForwardedMessageIDWithoutCaption
type StorageMockSetFavChannelLastForwardedMessageIDWithoutCaptionParams struct {
	i1 int64
}

// Expect sets up expected params for storage.SetFavChannelLastForwardedMessageIDWithoutCaption
func (mmSetFavChannelLastForwardedMessageIDWithoutCaption *mStorageMockSetFavChannelLastForwardedMessageIDWithoutCaption) Expect(i1 int64) *mStorageMockSetFavChannelLastForwardedMessageIDWithoutCaption {
	if mmSetFavChannelLastForwardedMessageIDWithoutCaption.mock.funcSetFavChannelLastForwardedMessageIDWithoutCaption != nil {
		mmSetFavChannelLastForwardedMessageIDWithoutCaption.mock.t.Fatalf("StorageMock.SetFavChannelLastForwardedMessageIDWithoutCaption mock is already set by Set")
	}

	if mmSetFavChannelLastForwardedMessageIDWithoutCaption.defaultExpectation == nil {
		mmSetFavChannelLastForwardedMessageIDWithoutCaption.defaultExpectation = &StorageMockSetFavChannelLastForwardedMessageIDWithoutCaptionExpectation{}
	}

	mmSetFavChannelLastForwardedMessageIDWithoutCaption.defaultExpectation.params = &StorageMockSetFavChannelLastForwardedMessageIDWithoutCaptionParams{i1}
	for _, e := range mmSetFavChannelLastForwardedMessageIDWithoutCaption.expectations {
		if minimock.Equal(e.params, mmSetFavChannelLastForwardedMessageIDWithoutCaption.defaultExpectation.params) {
			mmSetFavChannelLastForwardedMessageIDWithoutCaption.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmSetFavChannelLastForwardedMessageIDWithoutCaption.defaultExpectation.params)
		}
	}

	return mmSetFavChannelLastForwardedMessageIDWithoutCaption
}

// Inspect accepts an inspector function that has same arguments as the storage.SetFavChannelLastForwardedMessageIDWithoutCaption
func (mmSetFavChannelLastForwardedMessageIDWithoutCaption *mStorageMockSetFavChannelLastForwardedMessageIDWithoutCaption) Inspect(f func(i1 int64)) *mStorageMockSetFavChannelLastForwardedMessageIDWithoutCaption {
	if mmSetFavChannelLastForwardedMessageIDWithoutCaption.mock.inspectFuncSetFavChannelLastForwardedMessageIDWithoutCaption != nil {
		mmSetFavChannelLastForwardedMessageIDWithoutCaption.mock.t.Fatalf("Inspect function is already set for StorageMock.SetFavChannelLastForwardedMessageIDWithoutCaption")
	}

	mmSetFavChannelLastForwardedMessageIDWithoutCaption.mock.inspectFuncSetFavChannelLastForwardedMessageIDWithoutCaption = f

	return mmSetFavChannelLastForwardedMessageIDWithoutCaption
}

// Return sets up results that will be returned by storage.SetFavChannelLastForwardedMessageIDWithoutCaption
func (mmSetFavChannelLastForwardedMessageIDWithoutCaption *mStorageMockSetFavChannelLastForwardedMessageIDWithoutCaption) Return() *StorageMock {
	if mmSetFavChannelLastForwardedMessageIDWithoutCaption.mock.funcSetFavChannelLastForwardedMessageIDWithoutCaption != nil {
		mmSetFavChannelLastForwardedMessageIDWithoutCaption.mock.t.Fatalf("StorageMock.SetFavChannelLastForwardedMessageIDWithoutCaption mock is already set by Set")
	}

	if mmSetFavChannelLastForwardedMessageIDWithoutCaption.defaultExpectation == nil {
		mmSetFavChannelLastForwardedMessageIDWithoutCaption.defaultExpectation = &StorageMockSetFavChannelLastForwardedMessageIDWithoutCaptionExpectation{mock: mmSetFavChannelLastForwardedMessageIDWithoutCaption.mock}
	}

	return mmSetFavChannelLastForwardedMessageIDWithoutCaption.mock
}

//Set uses given function f to mock the storage.SetFavChannelLastForwardedMessageIDWithoutCaption method
func (mmSetFavChannelLastForwardedMessageIDWithoutCaption *mStorageMockSetFavChannelLastForwardedMessageIDWithoutCaption) Set(f func(i1 int64)) *StorageMock {
	if mmSetFavChannelLastForwardedMessageIDWithoutCaption.defaultExpectation != nil {
		mmSetFavChannelLastForwardedMessageIDWithoutCaption.mock.t.Fatalf("Default expectation is already set for the storage.SetFavChannelLastForwardedMessageIDWithoutCaption method")
	}

	if len(mmSetFavChannelLastForwardedMessageIDWithoutCaption.expectations) > 0 {
		mmSetFavChannelLastForwardedMessageIDWithoutCaption.mock.t.Fatalf("Some expectations are already set for the storage.SetFavChannelLastForwardedMessageIDWithoutCaption method")
	}

	mmSetFavChannelLastForwardedMessageIDWithoutCaption.mock.funcSetFavChannelLastForwardedMessageIDWithoutCaption = f
	return mmSetFavChannelLastForwardedMessageIDWithoutCaption.mock
}

// SetFavChannelLastForwardedMessageIDWithoutCaption implements storage
func (mmSetFavChannelLastForwardedMessageIDWithoutCaption *StorageMock) SetFavChannelLastForwardedMessageIDWithoutCaption(i1 int64) {
	mm_atomic.AddUint64(&mmSetFavChannelLastForwardedMessageIDWithoutCaption.beforeSetFavChannelLastForwardedMessageIDWithoutCaptionCounter, 1)
	defer mm_atomic.AddUint64(&mmSetFavChannelLastForwardedMessageIDWithoutCaption.afterSetFavChannelLastForwardedMessageIDWithoutCaptionCounter, 1)

	if mmSetFavChannelLastForwardedMessageIDWithoutCaption.inspectFuncSetFavChannelLastForwardedMessageIDWithoutCaption != nil {
		mmSetFavChannelLastForwardedMessageIDWithoutCaption.inspectFuncSetFavChannelLastForwardedMessageIDWithoutCaption(i1)
	}

	mm_params := &StorageMockSetFavChannelLastForwardedMessageIDWithoutCaptionParams{i1}

	// Record call args
	mmSetFavChannelLastForwardedMessageIDWithoutCaption.SetFavChannelLastForwardedMessageIDWithoutCaptionMock.mutex.Lock()
	mmSetFavChannelLastForwardedMessageIDWithoutCaption.SetFavChannelLastForwardedMessageIDWithoutCaptionMock.callArgs = append(mmSetFavChannelLastForwardedMessageIDWithoutCaption.SetFavChannelLastForwardedMessageIDWithoutCaptionMock.callArgs, mm_params)
	mmSetFavChannelLastForwardedMessageIDWithoutCaption.SetFavChannelLastForwardedMessageIDWithoutCaptionMock.mutex.Unlock()

	for _, e := range mmSetFavChannelLastForwardedMessageIDWithoutCaption.SetFavChannelLastForwardedMessageIDWithoutCaptionMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return
		}
	}

	if mmSetFavChannelLastForwardedMessageIDWithoutCaption.SetFavChannelLastForwardedMessageIDWithoutCaptionMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmSetFavChannelLastForwardedMessageIDWithoutCaption.SetFavChannelLastForwardedMessageIDWithoutCaptionMock.defaultExpectation.Counter, 1)
		mm_want := mmSetFavChannelLastForwardedMessageIDWithoutCaption.SetFavChannelLastForwardedMessageIDWithoutCaptionMock.defaultExpectation.params
		mm_got := StorageMockSetFavChannelLastForwardedMessageIDWithoutCaptionParams{i1}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmSetFavChannelLastForwardedMessageIDWithoutCaption.t.Errorf("StorageMock.SetFavChannelLastForwardedMessageIDWithoutCaption got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		return

	}
	if mmSetFavChannelLastForwardedMessageIDWithoutCaption.funcSetFavChannelLastForwardedMessageIDWithoutCaption != nil {
		mmSetFavChannelLastForwardedMessageIDWithoutCaption.funcSetFavChannelLastForwardedMessageIDWithoutCaption(i1)
		return
	}
	mmSetFavChannelLastForwardedMessageIDWithoutCaption.t.Fatalf("Unexpected call to StorageMock.SetFavChannelLastForwardedMessageIDWithoutCaption. %v", i1)

}

// SetFavChannelLastForwardedMessageIDWithoutCaptionAfterCounter returns a count of finished StorageMock.SetFavChannelLastForwardedMessageIDWithoutCaption invocations
func (mmSetFavChannelLastForwardedMessageIDWithoutCaption *StorageMock) SetFavChannelLastForwardedMessageIDWithoutCaptionAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSetFavChannelLastForwardedMessageIDWithoutCaption.afterSetFavChannelLastForwardedMessageIDWithoutCaptionCounter)
}

// SetFavChannelLastForwardedMessageIDWithoutCaptionBeforeCounter returns a count of StorageMock.SetFavChannelLastForwardedMessageIDWithoutCaption invocations
func (mmSetFavChannelLastForwardedMessageIDWithoutCaption *StorageMock) SetFavChannelLastForwardedMessageIDWithoutCaptionBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSetFavChannelLastForwardedMessageIDWithoutCaption.beforeSetFavChannelLastForwardedMessageIDWithoutCaptionCounter)
}

// Calls returns a list of arguments used in each call to StorageMock.SetFavChannelLastForwardedMessageIDWithoutCaption.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmSetFavChannelLastForwardedMessageIDWithoutCaption *mStorageMockSetFavChannelLastForwardedMessageIDWithoutCaption) Calls() []*StorageMockSetFavChannelLastForwardedMessageIDWithoutCaptionParams {
	mmSetFavChannelLastForwardedMessageIDWithoutCaption.mutex.RLock()

	argCopy := make([]*StorageMockSetFavChannelLastForwardedMessageIDWithoutCaptionParams, len(mmSetFavChannelLastForwardedMessageIDWithoutCaption.callArgs))
	copy(argCopy, mmSetFavChannelLastForwardedMessageIDWithoutCaption.callArgs)

	mmSetFavChannelLastForwardedMessageIDWithoutCaption.mutex.RUnlock()

	return argCopy
}

// MinimockSetFavChannelLastForwardedMessageIDWithoutCaptionDone returns true if the count of the SetFavChannelLastForwardedMessageIDWithoutCaption invocations corresponds
// the number of defined expectations
func (m *StorageMock) MinimockSetFavChannelLastForwardedMessageIDWithoutCaptionDone() bool {
	for _, e := range m.SetFavChannelLastForwardedMessageIDWithoutCaptionMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.SetFavChannelLastForwardedMessageIDWithoutCaptionMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterSetFavChannelLastForwardedMessageIDWithoutCaptionCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcSetFavChannelLastForwardedMessageIDWithoutCaption != nil && mm_atomic.LoadUint64(&m.afterSetFavChannelLastForwardedMessageIDWithoutCaptionCounter) < 1 {
		return false
	}
	return true
}

// MinimockSetFavChannelLastForwardedMessageIDWithoutCaptionInspect logs each unmet expectation
func (m *StorageMock) MinimockSetFavChannelLastForwardedMessageIDWithoutCaptionInspect() {
	for _, e := range m.SetFavChannelLastForwardedMessageIDWithoutCaptionMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to StorageMock.SetFavChannelLastForwardedMessageIDWithoutCaption with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.SetFavChannelLastForwardedMessageIDWithoutCaptionMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterSetFavChannelLastForwardedMessageIDWithoutCaptionCounter) < 1 {
		if m.SetFavChannelLastForwardedMessageIDWithoutCaptionMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to StorageMock.SetFavChannelLastForwardedMessageIDWithoutCaption")
		} else {
			m.t.Errorf("Expected call to StorageMock.SetFavChannelLastForwardedMessageIDWithoutCaption with params: %#v", *m.SetFavChannelLastForwardedMessageIDWithoutCaptionMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcSetFavChannelLastForwardedMessageIDWithoutCaption != nil && mm_atomic.LoadUint64(&m.afterSetFavChannelLastForwardedMessageIDWithoutCaptionCounter) < 1 {
		m.t.Error("Expected call to StorageMock.SetFavChannelLastForwardedMessageIDWithoutCaption")
	}
}

type mStorageMockSetTags struct {
	mock               *StorageMock
	defaultExpectation *StorageMockSetTagsExpectation
	expectations       []*StorageMockSetTagsExpectation

	callArgs []*StorageMockSetTagsParams
	mutex    sync.RWMutex
}

// StorageMockSetTagsExpectation specifies expectation struct of the storage.SetTags
type StorageMockSetTagsExpectation struct {
	mock   *StorageMock
	params *StorageMockSetTagsParams

	Counter uint64
}

// StorageMockSetTagsParams contains parameters of the storage.SetTags
type StorageMockSetTagsParams struct {
	sa1 []string
}

// Expect sets up expected params for storage.SetTags
func (mmSetTags *mStorageMockSetTags) Expect(sa1 []string) *mStorageMockSetTags {
	if mmSetTags.mock.funcSetTags != nil {
		mmSetTags.mock.t.Fatalf("StorageMock.SetTags mock is already set by Set")
	}

	if mmSetTags.defaultExpectation == nil {
		mmSetTags.defaultExpectation = &StorageMockSetTagsExpectation{}
	}

	mmSetTags.defaultExpectation.params = &StorageMockSetTagsParams{sa1}
	for _, e := range mmSetTags.expectations {
		if minimock.Equal(e.params, mmSetTags.defaultExpectation.params) {
			mmSetTags.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmSetTags.defaultExpectation.params)
		}
	}

	return mmSetTags
}

// Inspect accepts an inspector function that has same arguments as the storage.SetTags
func (mmSetTags *mStorageMockSetTags) Inspect(f func(sa1 []string)) *mStorageMockSetTags {
	if mmSetTags.mock.inspectFuncSetTags != nil {
		mmSetTags.mock.t.Fatalf("Inspect function is already set for StorageMock.SetTags")
	}

	mmSetTags.mock.inspectFuncSetTags = f

	return mmSetTags
}

// Return sets up results that will be returned by storage.SetTags
func (mmSetTags *mStorageMockSetTags) Return() *StorageMock {
	if mmSetTags.mock.funcSetTags != nil {
		mmSetTags.mock.t.Fatalf("StorageMock.SetTags mock is already set by Set")
	}

	if mmSetTags.defaultExpectation == nil {
		mmSetTags.defaultExpectation = &StorageMockSetTagsExpectation{mock: mmSetTags.mock}
	}

	return mmSetTags.mock
}

//Set uses given function f to mock the storage.SetTags method
func (mmSetTags *mStorageMockSetTags) Set(f func(sa1 []string)) *StorageMock {
	if mmSetTags.defaultExpectation != nil {
		mmSetTags.mock.t.Fatalf("Default expectation is already set for the storage.SetTags method")
	}

	if len(mmSetTags.expectations) > 0 {
		mmSetTags.mock.t.Fatalf("Some expectations are already set for the storage.SetTags method")
	}

	mmSetTags.mock.funcSetTags = f
	return mmSetTags.mock
}

// SetTags implements storage
func (mmSetTags *StorageMock) SetTags(sa1 []string) {
	mm_atomic.AddUint64(&mmSetTags.beforeSetTagsCounter, 1)
	defer mm_atomic.AddUint64(&mmSetTags.afterSetTagsCounter, 1)

	if mmSetTags.inspectFuncSetTags != nil {
		mmSetTags.inspectFuncSetTags(sa1)
	}

	mm_params := &StorageMockSetTagsParams{sa1}

	// Record call args
	mmSetTags.SetTagsMock.mutex.Lock()
	mmSetTags.SetTagsMock.callArgs = append(mmSetTags.SetTagsMock.callArgs, mm_params)
	mmSetTags.SetTagsMock.mutex.Unlock()

	for _, e := range mmSetTags.SetTagsMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return
		}
	}

	if mmSetTags.SetTagsMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmSetTags.SetTagsMock.defaultExpectation.Counter, 1)
		mm_want := mmSetTags.SetTagsMock.defaultExpectation.params
		mm_got := StorageMockSetTagsParams{sa1}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmSetTags.t.Errorf("StorageMock.SetTags got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		return

	}
	if mmSetTags.funcSetTags != nil {
		mmSetTags.funcSetTags(sa1)
		return
	}
	mmSetTags.t.Fatalf("Unexpected call to StorageMock.SetTags. %v", sa1)

}

// SetTagsAfterCounter returns a count of finished StorageMock.SetTags invocations
func (mmSetTags *StorageMock) SetTagsAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSetTags.afterSetTagsCounter)
}

// SetTagsBeforeCounter returns a count of StorageMock.SetTags invocations
func (mmSetTags *StorageMock) SetTagsBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSetTags.beforeSetTagsCounter)
}

// Calls returns a list of arguments used in each call to StorageMock.SetTags.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmSetTags *mStorageMockSetTags) Calls() []*StorageMockSetTagsParams {
	mmSetTags.mutex.RLock()

	argCopy := make([]*StorageMockSetTagsParams, len(mmSetTags.callArgs))
	copy(argCopy, mmSetTags.callArgs)

	mmSetTags.mutex.RUnlock()

	return argCopy
}

// MinimockSetTagsDone returns true if the count of the SetTags invocations corresponds
// the number of defined expectations
func (m *StorageMock) MinimockSetTagsDone() bool {
	for _, e := range m.SetTagsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.SetTagsMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterSetTagsCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcSetTags != nil && mm_atomic.LoadUint64(&m.afterSetTagsCounter) < 1 {
		return false
	}
	return true
}

// MinimockSetTagsInspect logs each unmet expectation
func (m *StorageMock) MinimockSetTagsInspect() {
	for _, e := range m.SetTagsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to StorageMock.SetTags with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.SetTagsMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterSetTagsCounter) < 1 {
		if m.SetTagsMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to StorageMock.SetTags")
		} else {
			m.t.Errorf("Expected call to StorageMock.SetTags with params: %#v", *m.SetTagsMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcSetTags != nil && mm_atomic.LoadUint64(&m.afterSetTagsCounter) < 1 {
		m.t.Error("Expected call to StorageMock.SetTags")
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *StorageMock) MinimockFinish() {
	if !m.minimockDone() {
		m.MinimockGetFavChannelLastForwardedMessageIDWithoutCaptionInspect()

		m.MinimockGetTagsInspect()

		m.MinimockSetFavChannelLastForwardedMessageIDWithoutCaptionInspect()

		m.MinimockSetTagsInspect()
		m.t.FailNow()
	}
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *StorageMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *StorageMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockGetFavChannelLastForwardedMessageIDWithoutCaptionDone() &&
		m.MinimockGetTagsDone() &&
		m.MinimockSetFavChannelLastForwardedMessageIDWithoutCaptionDone() &&
		m.MinimockSetTagsDone()
}
