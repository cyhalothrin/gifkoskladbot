package publish

// Code generated by http://github.com/gojuno/minimock (dev). DO NOT EDIT.

//go:generate minimock -i github.com/cyhalothrin/gifkoskladbot/bot.GifkoskladMetaStorage -o ./favchannel/publish/gifkosklad_meta_storage_mock_test.go

import (
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	"github.com/cyhalothrin/gifkoskladbot/storage"
	"github.com/gojuno/minimock/v3"
)

// GifkoskladMetaStorageMock implements bot.GifkoskladMetaStorage
type GifkoskladMetaStorageMock struct {
	t minimock.Tester

	funcAddSentAnimations          func(m1 map[string]*storage.SentAnimation)
	inspectFuncAddSentAnimations   func(m1 map[string]*storage.SentAnimation)
	afterAddSentAnimationsCounter  uint64
	beforeAddSentAnimationsCounter uint64
	AddSentAnimationsMock          mGifkoskladMetaStorageMockAddSentAnimations

	funcGetSentAnimations          func() (m1 map[string]*storage.SentAnimation)
	inspectFuncGetSentAnimations   func()
	afterGetSentAnimationsCounter  uint64
	beforeGetSentAnimationsCounter uint64
	GetSentAnimationsMock          mGifkoskladMetaStorageMockGetSentAnimations

	funcGetTags          func() (sa1 []string)
	inspectFuncGetTags   func()
	afterGetTagsCounter  uint64
	beforeGetTagsCounter uint64
	GetTagsMock          mGifkoskladMetaStorageMockGetTags

	funcGetTagsAliases          func() (m1 map[string]string)
	inspectFuncGetTagsAliases   func()
	afterGetTagsAliasesCounter  uint64
	beforeGetTagsAliasesCounter uint64
	GetTagsAliasesMock          mGifkoskladMetaStorageMockGetTagsAliases

	funcSetTags          func(sa1 []string)
	inspectFuncSetTags   func(sa1 []string)
	afterSetTagsCounter  uint64
	beforeSetTagsCounter uint64
	SetTagsMock          mGifkoskladMetaStorageMockSetTags

	funcSetTagsAliases          func(m1 map[string]string)
	inspectFuncSetTagsAliases   func(m1 map[string]string)
	afterSetTagsAliasesCounter  uint64
	beforeSetTagsAliasesCounter uint64
	SetTagsAliasesMock          mGifkoskladMetaStorageMockSetTagsAliases
}

// NewGifkoskladMetaStorageMock returns a mock for bot.GifkoskladMetaStorage
func NewGifkoskladMetaStorageMock(t minimock.Tester) *GifkoskladMetaStorageMock {
	m := &GifkoskladMetaStorageMock{t: t}
	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.AddSentAnimationsMock = mGifkoskladMetaStorageMockAddSentAnimations{mock: m}
	m.AddSentAnimationsMock.callArgs = []*GifkoskladMetaStorageMockAddSentAnimationsParams{}

	m.GetSentAnimationsMock = mGifkoskladMetaStorageMockGetSentAnimations{mock: m}

	m.GetTagsMock = mGifkoskladMetaStorageMockGetTags{mock: m}

	m.GetTagsAliasesMock = mGifkoskladMetaStorageMockGetTagsAliases{mock: m}

	m.SetTagsMock = mGifkoskladMetaStorageMockSetTags{mock: m}
	m.SetTagsMock.callArgs = []*GifkoskladMetaStorageMockSetTagsParams{}

	m.SetTagsAliasesMock = mGifkoskladMetaStorageMockSetTagsAliases{mock: m}
	m.SetTagsAliasesMock.callArgs = []*GifkoskladMetaStorageMockSetTagsAliasesParams{}

	return m
}

type mGifkoskladMetaStorageMockAddSentAnimations struct {
	mock               *GifkoskladMetaStorageMock
	defaultExpectation *GifkoskladMetaStorageMockAddSentAnimationsExpectation
	expectations       []*GifkoskladMetaStorageMockAddSentAnimationsExpectation

	callArgs []*GifkoskladMetaStorageMockAddSentAnimationsParams
	mutex    sync.RWMutex
}

// GifkoskladMetaStorageMockAddSentAnimationsExpectation specifies expectation struct of the GifkoskladMetaStorage.AddSentAnimations
type GifkoskladMetaStorageMockAddSentAnimationsExpectation struct {
	mock   *GifkoskladMetaStorageMock
	params *GifkoskladMetaStorageMockAddSentAnimationsParams

	Counter uint64
}

// GifkoskladMetaStorageMockAddSentAnimationsParams contains parameters of the GifkoskladMetaStorage.AddSentAnimations
type GifkoskladMetaStorageMockAddSentAnimationsParams struct {
	m1 map[string]*storage.SentAnimation
}

// Expect sets up expected params for GifkoskladMetaStorage.AddSentAnimations
func (mmAddSentAnimations *mGifkoskladMetaStorageMockAddSentAnimations) Expect(m1 map[string]*storage.SentAnimation) *mGifkoskladMetaStorageMockAddSentAnimations {
	if mmAddSentAnimations.mock.funcAddSentAnimations != nil {
		mmAddSentAnimations.mock.t.Fatalf("GifkoskladMetaStorageMock.AddSentAnimations mock is already set by Set")
	}

	if mmAddSentAnimations.defaultExpectation == nil {
		mmAddSentAnimations.defaultExpectation = &GifkoskladMetaStorageMockAddSentAnimationsExpectation{}
	}

	mmAddSentAnimations.defaultExpectation.params = &GifkoskladMetaStorageMockAddSentAnimationsParams{m1}
	for _, e := range mmAddSentAnimations.expectations {
		if minimock.Equal(e.params, mmAddSentAnimations.defaultExpectation.params) {
			mmAddSentAnimations.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmAddSentAnimations.defaultExpectation.params)
		}
	}

	return mmAddSentAnimations
}

// Inspect accepts an inspector function that has same arguments as the GifkoskladMetaStorage.AddSentAnimations
func (mmAddSentAnimations *mGifkoskladMetaStorageMockAddSentAnimations) Inspect(f func(m1 map[string]*storage.SentAnimation)) *mGifkoskladMetaStorageMockAddSentAnimations {
	if mmAddSentAnimations.mock.inspectFuncAddSentAnimations != nil {
		mmAddSentAnimations.mock.t.Fatalf("Inspect function is already set for GifkoskladMetaStorageMock.AddSentAnimations")
	}

	mmAddSentAnimations.mock.inspectFuncAddSentAnimations = f

	return mmAddSentAnimations
}

// Return sets up results that will be returned by GifkoskladMetaStorage.AddSentAnimations
func (mmAddSentAnimations *mGifkoskladMetaStorageMockAddSentAnimations) Return() *GifkoskladMetaStorageMock {
	if mmAddSentAnimations.mock.funcAddSentAnimations != nil {
		mmAddSentAnimations.mock.t.Fatalf("GifkoskladMetaStorageMock.AddSentAnimations mock is already set by Set")
	}

	if mmAddSentAnimations.defaultExpectation == nil {
		mmAddSentAnimations.defaultExpectation = &GifkoskladMetaStorageMockAddSentAnimationsExpectation{mock: mmAddSentAnimations.mock}
	}

	return mmAddSentAnimations.mock
}

//Set uses given function f to mock the GifkoskladMetaStorage.AddSentAnimations method
func (mmAddSentAnimations *mGifkoskladMetaStorageMockAddSentAnimations) Set(f func(m1 map[string]*storage.SentAnimation)) *GifkoskladMetaStorageMock {
	if mmAddSentAnimations.defaultExpectation != nil {
		mmAddSentAnimations.mock.t.Fatalf("Default expectation is already set for the GifkoskladMetaStorage.AddSentAnimations method")
	}

	if len(mmAddSentAnimations.expectations) > 0 {
		mmAddSentAnimations.mock.t.Fatalf("Some expectations are already set for the GifkoskladMetaStorage.AddSentAnimations method")
	}

	mmAddSentAnimations.mock.funcAddSentAnimations = f
	return mmAddSentAnimations.mock
}

// AddSentAnimations implements bot.GifkoskladMetaStorage
func (mmAddSentAnimations *GifkoskladMetaStorageMock) AddSentAnimations(m1 map[string]*storage.SentAnimation) {
	mm_atomic.AddUint64(&mmAddSentAnimations.beforeAddSentAnimationsCounter, 1)
	defer mm_atomic.AddUint64(&mmAddSentAnimations.afterAddSentAnimationsCounter, 1)

	if mmAddSentAnimations.inspectFuncAddSentAnimations != nil {
		mmAddSentAnimations.inspectFuncAddSentAnimations(m1)
	}

	mm_params := &GifkoskladMetaStorageMockAddSentAnimationsParams{m1}

	// Record call args
	mmAddSentAnimations.AddSentAnimationsMock.mutex.Lock()
	mmAddSentAnimations.AddSentAnimationsMock.callArgs = append(mmAddSentAnimations.AddSentAnimationsMock.callArgs, mm_params)
	mmAddSentAnimations.AddSentAnimationsMock.mutex.Unlock()

	for _, e := range mmAddSentAnimations.AddSentAnimationsMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return
		}
	}

	if mmAddSentAnimations.AddSentAnimationsMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmAddSentAnimations.AddSentAnimationsMock.defaultExpectation.Counter, 1)
		mm_want := mmAddSentAnimations.AddSentAnimationsMock.defaultExpectation.params
		mm_got := GifkoskladMetaStorageMockAddSentAnimationsParams{m1}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmAddSentAnimations.t.Errorf("GifkoskladMetaStorageMock.AddSentAnimations got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		return

	}
	if mmAddSentAnimations.funcAddSentAnimations != nil {
		mmAddSentAnimations.funcAddSentAnimations(m1)
		return
	}
	mmAddSentAnimations.t.Fatalf("Unexpected call to GifkoskladMetaStorageMock.AddSentAnimations. %v", m1)

}

// AddSentAnimationsAfterCounter returns a count of finished GifkoskladMetaStorageMock.AddSentAnimations invocations
func (mmAddSentAnimations *GifkoskladMetaStorageMock) AddSentAnimationsAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmAddSentAnimations.afterAddSentAnimationsCounter)
}

// AddSentAnimationsBeforeCounter returns a count of GifkoskladMetaStorageMock.AddSentAnimations invocations
func (mmAddSentAnimations *GifkoskladMetaStorageMock) AddSentAnimationsBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmAddSentAnimations.beforeAddSentAnimationsCounter)
}

// Calls returns a list of arguments used in each call to GifkoskladMetaStorageMock.AddSentAnimations.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmAddSentAnimations *mGifkoskladMetaStorageMockAddSentAnimations) Calls() []*GifkoskladMetaStorageMockAddSentAnimationsParams {
	mmAddSentAnimations.mutex.RLock()

	argCopy := make([]*GifkoskladMetaStorageMockAddSentAnimationsParams, len(mmAddSentAnimations.callArgs))
	copy(argCopy, mmAddSentAnimations.callArgs)

	mmAddSentAnimations.mutex.RUnlock()

	return argCopy
}

// MinimockAddSentAnimationsDone returns true if the count of the AddSentAnimations invocations corresponds
// the number of defined expectations
func (m *GifkoskladMetaStorageMock) MinimockAddSentAnimationsDone() bool {
	for _, e := range m.AddSentAnimationsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.AddSentAnimationsMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterAddSentAnimationsCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcAddSentAnimations != nil && mm_atomic.LoadUint64(&m.afterAddSentAnimationsCounter) < 1 {
		return false
	}
	return true
}

// MinimockAddSentAnimationsInspect logs each unmet expectation
func (m *GifkoskladMetaStorageMock) MinimockAddSentAnimationsInspect() {
	for _, e := range m.AddSentAnimationsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to GifkoskladMetaStorageMock.AddSentAnimations with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.AddSentAnimationsMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterAddSentAnimationsCounter) < 1 {
		if m.AddSentAnimationsMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to GifkoskladMetaStorageMock.AddSentAnimations")
		} else {
			m.t.Errorf("Expected call to GifkoskladMetaStorageMock.AddSentAnimations with params: %#v", *m.AddSentAnimationsMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcAddSentAnimations != nil && mm_atomic.LoadUint64(&m.afterAddSentAnimationsCounter) < 1 {
		m.t.Error("Expected call to GifkoskladMetaStorageMock.AddSentAnimations")
	}
}

type mGifkoskladMetaStorageMockGetSentAnimations struct {
	mock               *GifkoskladMetaStorageMock
	defaultExpectation *GifkoskladMetaStorageMockGetSentAnimationsExpectation
	expectations       []*GifkoskladMetaStorageMockGetSentAnimationsExpectation
}

// GifkoskladMetaStorageMockGetSentAnimationsExpectation specifies expectation struct of the GifkoskladMetaStorage.GetSentAnimations
type GifkoskladMetaStorageMockGetSentAnimationsExpectation struct {
	mock *GifkoskladMetaStorageMock

	results *GifkoskladMetaStorageMockGetSentAnimationsResults
	Counter uint64
}

// GifkoskladMetaStorageMockGetSentAnimationsResults contains results of the GifkoskladMetaStorage.GetSentAnimations
type GifkoskladMetaStorageMockGetSentAnimationsResults struct {
	m1 map[string]*storage.SentAnimation
}

// Expect sets up expected params for GifkoskladMetaStorage.GetSentAnimations
func (mmGetSentAnimations *mGifkoskladMetaStorageMockGetSentAnimations) Expect() *mGifkoskladMetaStorageMockGetSentAnimations {
	if mmGetSentAnimations.mock.funcGetSentAnimations != nil {
		mmGetSentAnimations.mock.t.Fatalf("GifkoskladMetaStorageMock.GetSentAnimations mock is already set by Set")
	}

	if mmGetSentAnimations.defaultExpectation == nil {
		mmGetSentAnimations.defaultExpectation = &GifkoskladMetaStorageMockGetSentAnimationsExpectation{}
	}

	return mmGetSentAnimations
}

// Inspect accepts an inspector function that has same arguments as the GifkoskladMetaStorage.GetSentAnimations
func (mmGetSentAnimations *mGifkoskladMetaStorageMockGetSentAnimations) Inspect(f func()) *mGifkoskladMetaStorageMockGetSentAnimations {
	if mmGetSentAnimations.mock.inspectFuncGetSentAnimations != nil {
		mmGetSentAnimations.mock.t.Fatalf("Inspect function is already set for GifkoskladMetaStorageMock.GetSentAnimations")
	}

	mmGetSentAnimations.mock.inspectFuncGetSentAnimations = f

	return mmGetSentAnimations
}

// Return sets up results that will be returned by GifkoskladMetaStorage.GetSentAnimations
func (mmGetSentAnimations *mGifkoskladMetaStorageMockGetSentAnimations) Return(m1 map[string]*storage.SentAnimation) *GifkoskladMetaStorageMock {
	if mmGetSentAnimations.mock.funcGetSentAnimations != nil {
		mmGetSentAnimations.mock.t.Fatalf("GifkoskladMetaStorageMock.GetSentAnimations mock is already set by Set")
	}

	if mmGetSentAnimations.defaultExpectation == nil {
		mmGetSentAnimations.defaultExpectation = &GifkoskladMetaStorageMockGetSentAnimationsExpectation{mock: mmGetSentAnimations.mock}
	}
	mmGetSentAnimations.defaultExpectation.results = &GifkoskladMetaStorageMockGetSentAnimationsResults{m1}
	return mmGetSentAnimations.mock
}

//Set uses given function f to mock the GifkoskladMetaStorage.GetSentAnimations method
func (mmGetSentAnimations *mGifkoskladMetaStorageMockGetSentAnimations) Set(f func() (m1 map[string]*storage.SentAnimation)) *GifkoskladMetaStorageMock {
	if mmGetSentAnimations.defaultExpectation != nil {
		mmGetSentAnimations.mock.t.Fatalf("Default expectation is already set for the GifkoskladMetaStorage.GetSentAnimations method")
	}

	if len(mmGetSentAnimations.expectations) > 0 {
		mmGetSentAnimations.mock.t.Fatalf("Some expectations are already set for the GifkoskladMetaStorage.GetSentAnimations method")
	}

	mmGetSentAnimations.mock.funcGetSentAnimations = f
	return mmGetSentAnimations.mock
}

// GetSentAnimations implements bot.GifkoskladMetaStorage
func (mmGetSentAnimations *GifkoskladMetaStorageMock) GetSentAnimations() (m1 map[string]*storage.SentAnimation) {
	mm_atomic.AddUint64(&mmGetSentAnimations.beforeGetSentAnimationsCounter, 1)
	defer mm_atomic.AddUint64(&mmGetSentAnimations.afterGetSentAnimationsCounter, 1)

	if mmGetSentAnimations.inspectFuncGetSentAnimations != nil {
		mmGetSentAnimations.inspectFuncGetSentAnimations()
	}

	if mmGetSentAnimations.GetSentAnimationsMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetSentAnimations.GetSentAnimationsMock.defaultExpectation.Counter, 1)

		mm_results := mmGetSentAnimations.GetSentAnimationsMock.defaultExpectation.results
		if mm_results == nil {
			mmGetSentAnimations.t.Fatal("No results are set for the GifkoskladMetaStorageMock.GetSentAnimations")
		}
		return (*mm_results).m1
	}
	if mmGetSentAnimations.funcGetSentAnimations != nil {
		return mmGetSentAnimations.funcGetSentAnimations()
	}
	mmGetSentAnimations.t.Fatalf("Unexpected call to GifkoskladMetaStorageMock.GetSentAnimations.")
	return
}

// GetSentAnimationsAfterCounter returns a count of finished GifkoskladMetaStorageMock.GetSentAnimations invocations
func (mmGetSentAnimations *GifkoskladMetaStorageMock) GetSentAnimationsAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetSentAnimations.afterGetSentAnimationsCounter)
}

// GetSentAnimationsBeforeCounter returns a count of GifkoskladMetaStorageMock.GetSentAnimations invocations
func (mmGetSentAnimations *GifkoskladMetaStorageMock) GetSentAnimationsBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetSentAnimations.beforeGetSentAnimationsCounter)
}

// MinimockGetSentAnimationsDone returns true if the count of the GetSentAnimations invocations corresponds
// the number of defined expectations
func (m *GifkoskladMetaStorageMock) MinimockGetSentAnimationsDone() bool {
	for _, e := range m.GetSentAnimationsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetSentAnimationsMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetSentAnimationsCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetSentAnimations != nil && mm_atomic.LoadUint64(&m.afterGetSentAnimationsCounter) < 1 {
		return false
	}
	return true
}

// MinimockGetSentAnimationsInspect logs each unmet expectation
func (m *GifkoskladMetaStorageMock) MinimockGetSentAnimationsInspect() {
	for _, e := range m.GetSentAnimationsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to GifkoskladMetaStorageMock.GetSentAnimations")
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetSentAnimationsMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetSentAnimationsCounter) < 1 {
		m.t.Error("Expected call to GifkoskladMetaStorageMock.GetSentAnimations")
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetSentAnimations != nil && mm_atomic.LoadUint64(&m.afterGetSentAnimationsCounter) < 1 {
		m.t.Error("Expected call to GifkoskladMetaStorageMock.GetSentAnimations")
	}
}

type mGifkoskladMetaStorageMockGetTags struct {
	mock               *GifkoskladMetaStorageMock
	defaultExpectation *GifkoskladMetaStorageMockGetTagsExpectation
	expectations       []*GifkoskladMetaStorageMockGetTagsExpectation
}

// GifkoskladMetaStorageMockGetTagsExpectation specifies expectation struct of the GifkoskladMetaStorage.GetTags
type GifkoskladMetaStorageMockGetTagsExpectation struct {
	mock *GifkoskladMetaStorageMock

	results *GifkoskladMetaStorageMockGetTagsResults
	Counter uint64
}

// GifkoskladMetaStorageMockGetTagsResults contains results of the GifkoskladMetaStorage.GetTags
type GifkoskladMetaStorageMockGetTagsResults struct {
	sa1 []string
}

// Expect sets up expected params for GifkoskladMetaStorage.GetTags
func (mmGetTags *mGifkoskladMetaStorageMockGetTags) Expect() *mGifkoskladMetaStorageMockGetTags {
	if mmGetTags.mock.funcGetTags != nil {
		mmGetTags.mock.t.Fatalf("GifkoskladMetaStorageMock.GetTags mock is already set by Set")
	}

	if mmGetTags.defaultExpectation == nil {
		mmGetTags.defaultExpectation = &GifkoskladMetaStorageMockGetTagsExpectation{}
	}

	return mmGetTags
}

// Inspect accepts an inspector function that has same arguments as the GifkoskladMetaStorage.GetTags
func (mmGetTags *mGifkoskladMetaStorageMockGetTags) Inspect(f func()) *mGifkoskladMetaStorageMockGetTags {
	if mmGetTags.mock.inspectFuncGetTags != nil {
		mmGetTags.mock.t.Fatalf("Inspect function is already set for GifkoskladMetaStorageMock.GetTags")
	}

	mmGetTags.mock.inspectFuncGetTags = f

	return mmGetTags
}

// Return sets up results that will be returned by GifkoskladMetaStorage.GetTags
func (mmGetTags *mGifkoskladMetaStorageMockGetTags) Return(sa1 []string) *GifkoskladMetaStorageMock {
	if mmGetTags.mock.funcGetTags != nil {
		mmGetTags.mock.t.Fatalf("GifkoskladMetaStorageMock.GetTags mock is already set by Set")
	}

	if mmGetTags.defaultExpectation == nil {
		mmGetTags.defaultExpectation = &GifkoskladMetaStorageMockGetTagsExpectation{mock: mmGetTags.mock}
	}
	mmGetTags.defaultExpectation.results = &GifkoskladMetaStorageMockGetTagsResults{sa1}
	return mmGetTags.mock
}

//Set uses given function f to mock the GifkoskladMetaStorage.GetTags method
func (mmGetTags *mGifkoskladMetaStorageMockGetTags) Set(f func() (sa1 []string)) *GifkoskladMetaStorageMock {
	if mmGetTags.defaultExpectation != nil {
		mmGetTags.mock.t.Fatalf("Default expectation is already set for the GifkoskladMetaStorage.GetTags method")
	}

	if len(mmGetTags.expectations) > 0 {
		mmGetTags.mock.t.Fatalf("Some expectations are already set for the GifkoskladMetaStorage.GetTags method")
	}

	mmGetTags.mock.funcGetTags = f
	return mmGetTags.mock
}

// GetTags implements bot.GifkoskladMetaStorage
func (mmGetTags *GifkoskladMetaStorageMock) GetTags() (sa1 []string) {
	mm_atomic.AddUint64(&mmGetTags.beforeGetTagsCounter, 1)
	defer mm_atomic.AddUint64(&mmGetTags.afterGetTagsCounter, 1)

	if mmGetTags.inspectFuncGetTags != nil {
		mmGetTags.inspectFuncGetTags()
	}

	if mmGetTags.GetTagsMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetTags.GetTagsMock.defaultExpectation.Counter, 1)

		mm_results := mmGetTags.GetTagsMock.defaultExpectation.results
		if mm_results == nil {
			mmGetTags.t.Fatal("No results are set for the GifkoskladMetaStorageMock.GetTags")
		}
		return (*mm_results).sa1
	}
	if mmGetTags.funcGetTags != nil {
		return mmGetTags.funcGetTags()
	}
	mmGetTags.t.Fatalf("Unexpected call to GifkoskladMetaStorageMock.GetTags.")
	return
}

// GetTagsAfterCounter returns a count of finished GifkoskladMetaStorageMock.GetTags invocations
func (mmGetTags *GifkoskladMetaStorageMock) GetTagsAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetTags.afterGetTagsCounter)
}

// GetTagsBeforeCounter returns a count of GifkoskladMetaStorageMock.GetTags invocations
func (mmGetTags *GifkoskladMetaStorageMock) GetTagsBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetTags.beforeGetTagsCounter)
}

// MinimockGetTagsDone returns true if the count of the GetTags invocations corresponds
// the number of defined expectations
func (m *GifkoskladMetaStorageMock) MinimockGetTagsDone() bool {
	for _, e := range m.GetTagsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetTagsMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetTagsCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetTags != nil && mm_atomic.LoadUint64(&m.afterGetTagsCounter) < 1 {
		return false
	}
	return true
}

// MinimockGetTagsInspect logs each unmet expectation
func (m *GifkoskladMetaStorageMock) MinimockGetTagsInspect() {
	for _, e := range m.GetTagsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to GifkoskladMetaStorageMock.GetTags")
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetTagsMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetTagsCounter) < 1 {
		m.t.Error("Expected call to GifkoskladMetaStorageMock.GetTags")
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetTags != nil && mm_atomic.LoadUint64(&m.afterGetTagsCounter) < 1 {
		m.t.Error("Expected call to GifkoskladMetaStorageMock.GetTags")
	}
}

type mGifkoskladMetaStorageMockGetTagsAliases struct {
	mock               *GifkoskladMetaStorageMock
	defaultExpectation *GifkoskladMetaStorageMockGetTagsAliasesExpectation
	expectations       []*GifkoskladMetaStorageMockGetTagsAliasesExpectation
}

// GifkoskladMetaStorageMockGetTagsAliasesExpectation specifies expectation struct of the GifkoskladMetaStorage.GetTagsAliases
type GifkoskladMetaStorageMockGetTagsAliasesExpectation struct {
	mock *GifkoskladMetaStorageMock

	results *GifkoskladMetaStorageMockGetTagsAliasesResults
	Counter uint64
}

// GifkoskladMetaStorageMockGetTagsAliasesResults contains results of the GifkoskladMetaStorage.GetTagsAliases
type GifkoskladMetaStorageMockGetTagsAliasesResults struct {
	m1 map[string]string
}

// Expect sets up expected params for GifkoskladMetaStorage.GetTagsAliases
func (mmGetTagsAliases *mGifkoskladMetaStorageMockGetTagsAliases) Expect() *mGifkoskladMetaStorageMockGetTagsAliases {
	if mmGetTagsAliases.mock.funcGetTagsAliases != nil {
		mmGetTagsAliases.mock.t.Fatalf("GifkoskladMetaStorageMock.GetTagsAliases mock is already set by Set")
	}

	if mmGetTagsAliases.defaultExpectation == nil {
		mmGetTagsAliases.defaultExpectation = &GifkoskladMetaStorageMockGetTagsAliasesExpectation{}
	}

	return mmGetTagsAliases
}

// Inspect accepts an inspector function that has same arguments as the GifkoskladMetaStorage.GetTagsAliases
func (mmGetTagsAliases *mGifkoskladMetaStorageMockGetTagsAliases) Inspect(f func()) *mGifkoskladMetaStorageMockGetTagsAliases {
	if mmGetTagsAliases.mock.inspectFuncGetTagsAliases != nil {
		mmGetTagsAliases.mock.t.Fatalf("Inspect function is already set for GifkoskladMetaStorageMock.GetTagsAliases")
	}

	mmGetTagsAliases.mock.inspectFuncGetTagsAliases = f

	return mmGetTagsAliases
}

// Return sets up results that will be returned by GifkoskladMetaStorage.GetTagsAliases
func (mmGetTagsAliases *mGifkoskladMetaStorageMockGetTagsAliases) Return(m1 map[string]string) *GifkoskladMetaStorageMock {
	if mmGetTagsAliases.mock.funcGetTagsAliases != nil {
		mmGetTagsAliases.mock.t.Fatalf("GifkoskladMetaStorageMock.GetTagsAliases mock is already set by Set")
	}

	if mmGetTagsAliases.defaultExpectation == nil {
		mmGetTagsAliases.defaultExpectation = &GifkoskladMetaStorageMockGetTagsAliasesExpectation{mock: mmGetTagsAliases.mock}
	}
	mmGetTagsAliases.defaultExpectation.results = &GifkoskladMetaStorageMockGetTagsAliasesResults{m1}
	return mmGetTagsAliases.mock
}

//Set uses given function f to mock the GifkoskladMetaStorage.GetTagsAliases method
func (mmGetTagsAliases *mGifkoskladMetaStorageMockGetTagsAliases) Set(f func() (m1 map[string]string)) *GifkoskladMetaStorageMock {
	if mmGetTagsAliases.defaultExpectation != nil {
		mmGetTagsAliases.mock.t.Fatalf("Default expectation is already set for the GifkoskladMetaStorage.GetTagsAliases method")
	}

	if len(mmGetTagsAliases.expectations) > 0 {
		mmGetTagsAliases.mock.t.Fatalf("Some expectations are already set for the GifkoskladMetaStorage.GetTagsAliases method")
	}

	mmGetTagsAliases.mock.funcGetTagsAliases = f
	return mmGetTagsAliases.mock
}

// GetTagsAliases implements bot.GifkoskladMetaStorage
func (mmGetTagsAliases *GifkoskladMetaStorageMock) GetTagsAliases() (m1 map[string]string) {
	mm_atomic.AddUint64(&mmGetTagsAliases.beforeGetTagsAliasesCounter, 1)
	defer mm_atomic.AddUint64(&mmGetTagsAliases.afterGetTagsAliasesCounter, 1)

	if mmGetTagsAliases.inspectFuncGetTagsAliases != nil {
		mmGetTagsAliases.inspectFuncGetTagsAliases()
	}

	if mmGetTagsAliases.GetTagsAliasesMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetTagsAliases.GetTagsAliasesMock.defaultExpectation.Counter, 1)

		mm_results := mmGetTagsAliases.GetTagsAliasesMock.defaultExpectation.results
		if mm_results == nil {
			mmGetTagsAliases.t.Fatal("No results are set for the GifkoskladMetaStorageMock.GetTagsAliases")
		}
		return (*mm_results).m1
	}
	if mmGetTagsAliases.funcGetTagsAliases != nil {
		return mmGetTagsAliases.funcGetTagsAliases()
	}
	mmGetTagsAliases.t.Fatalf("Unexpected call to GifkoskladMetaStorageMock.GetTagsAliases.")
	return
}

// GetTagsAliasesAfterCounter returns a count of finished GifkoskladMetaStorageMock.GetTagsAliases invocations
func (mmGetTagsAliases *GifkoskladMetaStorageMock) GetTagsAliasesAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetTagsAliases.afterGetTagsAliasesCounter)
}

// GetTagsAliasesBeforeCounter returns a count of GifkoskladMetaStorageMock.GetTagsAliases invocations
func (mmGetTagsAliases *GifkoskladMetaStorageMock) GetTagsAliasesBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetTagsAliases.beforeGetTagsAliasesCounter)
}

// MinimockGetTagsAliasesDone returns true if the count of the GetTagsAliases invocations corresponds
// the number of defined expectations
func (m *GifkoskladMetaStorageMock) MinimockGetTagsAliasesDone() bool {
	for _, e := range m.GetTagsAliasesMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetTagsAliasesMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetTagsAliasesCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetTagsAliases != nil && mm_atomic.LoadUint64(&m.afterGetTagsAliasesCounter) < 1 {
		return false
	}
	return true
}

// MinimockGetTagsAliasesInspect logs each unmet expectation
func (m *GifkoskladMetaStorageMock) MinimockGetTagsAliasesInspect() {
	for _, e := range m.GetTagsAliasesMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to GifkoskladMetaStorageMock.GetTagsAliases")
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetTagsAliasesMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetTagsAliasesCounter) < 1 {
		m.t.Error("Expected call to GifkoskladMetaStorageMock.GetTagsAliases")
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetTagsAliases != nil && mm_atomic.LoadUint64(&m.afterGetTagsAliasesCounter) < 1 {
		m.t.Error("Expected call to GifkoskladMetaStorageMock.GetTagsAliases")
	}
}

type mGifkoskladMetaStorageMockSetTags struct {
	mock               *GifkoskladMetaStorageMock
	defaultExpectation *GifkoskladMetaStorageMockSetTagsExpectation
	expectations       []*GifkoskladMetaStorageMockSetTagsExpectation

	callArgs []*GifkoskladMetaStorageMockSetTagsParams
	mutex    sync.RWMutex
}

// GifkoskladMetaStorageMockSetTagsExpectation specifies expectation struct of the GifkoskladMetaStorage.SetTags
type GifkoskladMetaStorageMockSetTagsExpectation struct {
	mock   *GifkoskladMetaStorageMock
	params *GifkoskladMetaStorageMockSetTagsParams

	Counter uint64
}

// GifkoskladMetaStorageMockSetTagsParams contains parameters of the GifkoskladMetaStorage.SetTags
type GifkoskladMetaStorageMockSetTagsParams struct {
	sa1 []string
}

// Expect sets up expected params for GifkoskladMetaStorage.SetTags
func (mmSetTags *mGifkoskladMetaStorageMockSetTags) Expect(sa1 []string) *mGifkoskladMetaStorageMockSetTags {
	if mmSetTags.mock.funcSetTags != nil {
		mmSetTags.mock.t.Fatalf("GifkoskladMetaStorageMock.SetTags mock is already set by Set")
	}

	if mmSetTags.defaultExpectation == nil {
		mmSetTags.defaultExpectation = &GifkoskladMetaStorageMockSetTagsExpectation{}
	}

	mmSetTags.defaultExpectation.params = &GifkoskladMetaStorageMockSetTagsParams{sa1}
	for _, e := range mmSetTags.expectations {
		if minimock.Equal(e.params, mmSetTags.defaultExpectation.params) {
			mmSetTags.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmSetTags.defaultExpectation.params)
		}
	}

	return mmSetTags
}

// Inspect accepts an inspector function that has same arguments as the GifkoskladMetaStorage.SetTags
func (mmSetTags *mGifkoskladMetaStorageMockSetTags) Inspect(f func(sa1 []string)) *mGifkoskladMetaStorageMockSetTags {
	if mmSetTags.mock.inspectFuncSetTags != nil {
		mmSetTags.mock.t.Fatalf("Inspect function is already set for GifkoskladMetaStorageMock.SetTags")
	}

	mmSetTags.mock.inspectFuncSetTags = f

	return mmSetTags
}

// Return sets up results that will be returned by GifkoskladMetaStorage.SetTags
func (mmSetTags *mGifkoskladMetaStorageMockSetTags) Return() *GifkoskladMetaStorageMock {
	if mmSetTags.mock.funcSetTags != nil {
		mmSetTags.mock.t.Fatalf("GifkoskladMetaStorageMock.SetTags mock is already set by Set")
	}

	if mmSetTags.defaultExpectation == nil {
		mmSetTags.defaultExpectation = &GifkoskladMetaStorageMockSetTagsExpectation{mock: mmSetTags.mock}
	}

	return mmSetTags.mock
}

//Set uses given function f to mock the GifkoskladMetaStorage.SetTags method
func (mmSetTags *mGifkoskladMetaStorageMockSetTags) Set(f func(sa1 []string)) *GifkoskladMetaStorageMock {
	if mmSetTags.defaultExpectation != nil {
		mmSetTags.mock.t.Fatalf("Default expectation is already set for the GifkoskladMetaStorage.SetTags method")
	}

	if len(mmSetTags.expectations) > 0 {
		mmSetTags.mock.t.Fatalf("Some expectations are already set for the GifkoskladMetaStorage.SetTags method")
	}

	mmSetTags.mock.funcSetTags = f
	return mmSetTags.mock
}

// SetTags implements bot.GifkoskladMetaStorage
func (mmSetTags *GifkoskladMetaStorageMock) SetTags(sa1 []string) {
	mm_atomic.AddUint64(&mmSetTags.beforeSetTagsCounter, 1)
	defer mm_atomic.AddUint64(&mmSetTags.afterSetTagsCounter, 1)

	if mmSetTags.inspectFuncSetTags != nil {
		mmSetTags.inspectFuncSetTags(sa1)
	}

	mm_params := &GifkoskladMetaStorageMockSetTagsParams{sa1}

	// Record call args
	mmSetTags.SetTagsMock.mutex.Lock()
	mmSetTags.SetTagsMock.callArgs = append(mmSetTags.SetTagsMock.callArgs, mm_params)
	mmSetTags.SetTagsMock.mutex.Unlock()

	for _, e := range mmSetTags.SetTagsMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return
		}
	}

	if mmSetTags.SetTagsMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmSetTags.SetTagsMock.defaultExpectation.Counter, 1)
		mm_want := mmSetTags.SetTagsMock.defaultExpectation.params
		mm_got := GifkoskladMetaStorageMockSetTagsParams{sa1}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmSetTags.t.Errorf("GifkoskladMetaStorageMock.SetTags got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		return

	}
	if mmSetTags.funcSetTags != nil {
		mmSetTags.funcSetTags(sa1)
		return
	}
	mmSetTags.t.Fatalf("Unexpected call to GifkoskladMetaStorageMock.SetTags. %v", sa1)

}

// SetTagsAfterCounter returns a count of finished GifkoskladMetaStorageMock.SetTags invocations
func (mmSetTags *GifkoskladMetaStorageMock) SetTagsAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSetTags.afterSetTagsCounter)
}

// SetTagsBeforeCounter returns a count of GifkoskladMetaStorageMock.SetTags invocations
func (mmSetTags *GifkoskladMetaStorageMock) SetTagsBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSetTags.beforeSetTagsCounter)
}

// Calls returns a list of arguments used in each call to GifkoskladMetaStorageMock.SetTags.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmSetTags *mGifkoskladMetaStorageMockSetTags) Calls() []*GifkoskladMetaStorageMockSetTagsParams {
	mmSetTags.mutex.RLock()

	argCopy := make([]*GifkoskladMetaStorageMockSetTagsParams, len(mmSetTags.callArgs))
	copy(argCopy, mmSetTags.callArgs)

	mmSetTags.mutex.RUnlock()

	return argCopy
}

// MinimockSetTagsDone returns true if the count of the SetTags invocations corresponds
// the number of defined expectations
func (m *GifkoskladMetaStorageMock) MinimockSetTagsDone() bool {
	for _, e := range m.SetTagsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.SetTagsMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterSetTagsCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcSetTags != nil && mm_atomic.LoadUint64(&m.afterSetTagsCounter) < 1 {
		return false
	}
	return true
}

// MinimockSetTagsInspect logs each unmet expectation
func (m *GifkoskladMetaStorageMock) MinimockSetTagsInspect() {
	for _, e := range m.SetTagsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to GifkoskladMetaStorageMock.SetTags with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.SetTagsMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterSetTagsCounter) < 1 {
		if m.SetTagsMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to GifkoskladMetaStorageMock.SetTags")
		} else {
			m.t.Errorf("Expected call to GifkoskladMetaStorageMock.SetTags with params: %#v", *m.SetTagsMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcSetTags != nil && mm_atomic.LoadUint64(&m.afterSetTagsCounter) < 1 {
		m.t.Error("Expected call to GifkoskladMetaStorageMock.SetTags")
	}
}

type mGifkoskladMetaStorageMockSetTagsAliases struct {
	mock               *GifkoskladMetaStorageMock
	defaultExpectation *GifkoskladMetaStorageMockSetTagsAliasesExpectation
	expectations       []*GifkoskladMetaStorageMockSetTagsAliasesExpectation

	callArgs []*GifkoskladMetaStorageMockSetTagsAliasesParams
	mutex    sync.RWMutex
}

// GifkoskladMetaStorageMockSetTagsAliasesExpectation specifies expectation struct of the GifkoskladMetaStorage.SetTagsAliases
type GifkoskladMetaStorageMockSetTagsAliasesExpectation struct {
	mock   *GifkoskladMetaStorageMock
	params *GifkoskladMetaStorageMockSetTagsAliasesParams

	Counter uint64
}

// GifkoskladMetaStorageMockSetTagsAliasesParams contains parameters of the GifkoskladMetaStorage.SetTagsAliases
type GifkoskladMetaStorageMockSetTagsAliasesParams struct {
	m1 map[string]string
}

// Expect sets up expected params for GifkoskladMetaStorage.SetTagsAliases
func (mmSetTagsAliases *mGifkoskladMetaStorageMockSetTagsAliases) Expect(m1 map[string]string) *mGifkoskladMetaStorageMockSetTagsAliases {
	if mmSetTagsAliases.mock.funcSetTagsAliases != nil {
		mmSetTagsAliases.mock.t.Fatalf("GifkoskladMetaStorageMock.SetTagsAliases mock is already set by Set")
	}

	if mmSetTagsAliases.defaultExpectation == nil {
		mmSetTagsAliases.defaultExpectation = &GifkoskladMetaStorageMockSetTagsAliasesExpectation{}
	}

	mmSetTagsAliases.defaultExpectation.params = &GifkoskladMetaStorageMockSetTagsAliasesParams{m1}
	for _, e := range mmSetTagsAliases.expectations {
		if minimock.Equal(e.params, mmSetTagsAliases.defaultExpectation.params) {
			mmSetTagsAliases.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmSetTagsAliases.defaultExpectation.params)
		}
	}

	return mmSetTagsAliases
}

// Inspect accepts an inspector function that has same arguments as the GifkoskladMetaStorage.SetTagsAliases
func (mmSetTagsAliases *mGifkoskladMetaStorageMockSetTagsAliases) Inspect(f func(m1 map[string]string)) *mGifkoskladMetaStorageMockSetTagsAliases {
	if mmSetTagsAliases.mock.inspectFuncSetTagsAliases != nil {
		mmSetTagsAliases.mock.t.Fatalf("Inspect function is already set for GifkoskladMetaStorageMock.SetTagsAliases")
	}

	mmSetTagsAliases.mock.inspectFuncSetTagsAliases = f

	return mmSetTagsAliases
}

// Return sets up results that will be returned by GifkoskladMetaStorage.SetTagsAliases
func (mmSetTagsAliases *mGifkoskladMetaStorageMockSetTagsAliases) Return() *GifkoskladMetaStorageMock {
	if mmSetTagsAliases.mock.funcSetTagsAliases != nil {
		mmSetTagsAliases.mock.t.Fatalf("GifkoskladMetaStorageMock.SetTagsAliases mock is already set by Set")
	}

	if mmSetTagsAliases.defaultExpectation == nil {
		mmSetTagsAliases.defaultExpectation = &GifkoskladMetaStorageMockSetTagsAliasesExpectation{mock: mmSetTagsAliases.mock}
	}

	return mmSetTagsAliases.mock
}

//Set uses given function f to mock the GifkoskladMetaStorage.SetTagsAliases method
func (mmSetTagsAliases *mGifkoskladMetaStorageMockSetTagsAliases) Set(f func(m1 map[string]string)) *GifkoskladMetaStorageMock {
	if mmSetTagsAliases.defaultExpectation != nil {
		mmSetTagsAliases.mock.t.Fatalf("Default expectation is already set for the GifkoskladMetaStorage.SetTagsAliases method")
	}

	if len(mmSetTagsAliases.expectations) > 0 {
		mmSetTagsAliases.mock.t.Fatalf("Some expectations are already set for the GifkoskladMetaStorage.SetTagsAliases method")
	}

	mmSetTagsAliases.mock.funcSetTagsAliases = f
	return mmSetTagsAliases.mock
}

// SetTagsAliases implements bot.GifkoskladMetaStorage
func (mmSetTagsAliases *GifkoskladMetaStorageMock) SetTagsAliases(m1 map[string]string) {
	mm_atomic.AddUint64(&mmSetTagsAliases.beforeSetTagsAliasesCounter, 1)
	defer mm_atomic.AddUint64(&mmSetTagsAliases.afterSetTagsAliasesCounter, 1)

	if mmSetTagsAliases.inspectFuncSetTagsAliases != nil {
		mmSetTagsAliases.inspectFuncSetTagsAliases(m1)
	}

	mm_params := &GifkoskladMetaStorageMockSetTagsAliasesParams{m1}

	// Record call args
	mmSetTagsAliases.SetTagsAliasesMock.mutex.Lock()
	mmSetTagsAliases.SetTagsAliasesMock.callArgs = append(mmSetTagsAliases.SetTagsAliasesMock.callArgs, mm_params)
	mmSetTagsAliases.SetTagsAliasesMock.mutex.Unlock()

	for _, e := range mmSetTagsAliases.SetTagsAliasesMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return
		}
	}

	if mmSetTagsAliases.SetTagsAliasesMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmSetTagsAliases.SetTagsAliasesMock.defaultExpectation.Counter, 1)
		mm_want := mmSetTagsAliases.SetTagsAliasesMock.defaultExpectation.params
		mm_got := GifkoskladMetaStorageMockSetTagsAliasesParams{m1}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmSetTagsAliases.t.Errorf("GifkoskladMetaStorageMock.SetTagsAliases got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		return

	}
	if mmSetTagsAliases.funcSetTagsAliases != nil {
		mmSetTagsAliases.funcSetTagsAliases(m1)
		return
	}
	mmSetTagsAliases.t.Fatalf("Unexpected call to GifkoskladMetaStorageMock.SetTagsAliases. %v", m1)

}

// SetTagsAliasesAfterCounter returns a count of finished GifkoskladMetaStorageMock.SetTagsAliases invocations
func (mmSetTagsAliases *GifkoskladMetaStorageMock) SetTagsAliasesAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSetTagsAliases.afterSetTagsAliasesCounter)
}

// SetTagsAliasesBeforeCounter returns a count of GifkoskladMetaStorageMock.SetTagsAliases invocations
func (mmSetTagsAliases *GifkoskladMetaStorageMock) SetTagsAliasesBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSetTagsAliases.beforeSetTagsAliasesCounter)
}

// Calls returns a list of arguments used in each call to GifkoskladMetaStorageMock.SetTagsAliases.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmSetTagsAliases *mGifkoskladMetaStorageMockSetTagsAliases) Calls() []*GifkoskladMetaStorageMockSetTagsAliasesParams {
	mmSetTagsAliases.mutex.RLock()

	argCopy := make([]*GifkoskladMetaStorageMockSetTagsAliasesParams, len(mmSetTagsAliases.callArgs))
	copy(argCopy, mmSetTagsAliases.callArgs)

	mmSetTagsAliases.mutex.RUnlock()

	return argCopy
}

// MinimockSetTagsAliasesDone returns true if the count of the SetTagsAliases invocations corresponds
// the number of defined expectations
func (m *GifkoskladMetaStorageMock) MinimockSetTagsAliasesDone() bool {
	for _, e := range m.SetTagsAliasesMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.SetTagsAliasesMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterSetTagsAliasesCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcSetTagsAliases != nil && mm_atomic.LoadUint64(&m.afterSetTagsAliasesCounter) < 1 {
		return false
	}
	return true
}

// MinimockSetTagsAliasesInspect logs each unmet expectation
func (m *GifkoskladMetaStorageMock) MinimockSetTagsAliasesInspect() {
	for _, e := range m.SetTagsAliasesMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to GifkoskladMetaStorageMock.SetTagsAliases with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.SetTagsAliasesMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterSetTagsAliasesCounter) < 1 {
		if m.SetTagsAliasesMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to GifkoskladMetaStorageMock.SetTagsAliases")
		} else {
			m.t.Errorf("Expected call to GifkoskladMetaStorageMock.SetTagsAliases with params: %#v", *m.SetTagsAliasesMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcSetTagsAliases != nil && mm_atomic.LoadUint64(&m.afterSetTagsAliasesCounter) < 1 {
		m.t.Error("Expected call to GifkoskladMetaStorageMock.SetTagsAliases")
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *GifkoskladMetaStorageMock) MinimockFinish() {
	if !m.minimockDone() {
		m.MinimockAddSentAnimationsInspect()

		m.MinimockGetSentAnimationsInspect()

		m.MinimockGetTagsInspect()

		m.MinimockGetTagsAliasesInspect()

		m.MinimockSetTagsInspect()

		m.MinimockSetTagsAliasesInspect()
		m.t.FailNow()
	}
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *GifkoskladMetaStorageMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *GifkoskladMetaStorageMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockAddSentAnimationsDone() &&
		m.MinimockGetSentAnimationsDone() &&
		m.MinimockGetTagsDone() &&
		m.MinimockGetTagsAliasesDone() &&
		m.MinimockSetTagsDone() &&
		m.MinimockSetTagsAliasesDone()
}
