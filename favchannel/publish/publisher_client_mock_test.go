package publish

// Code generated by http://github.com/gojuno/minimock (dev). DO NOT EDIT.

//go:generate minimock -i github.com/cyhalothrin/gifkoskladbot/favchannel/publish.publisherClient -o ./favchannel/publish/publisher_client_mock_test.go

import (
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	"github.com/Arman92/go-tdlib"
	"github.com/gojuno/minimock/v3"
)

// PublisherClientMock implements publisherClient
type PublisherClientMock struct {
	t minimock.Tester

	funcEditMessageCaption          func(chatID int64, messageID int64, caption string) (err error)
	inspectFuncEditMessageCaption   func(chatID int64, messageID int64, caption string)
	afterEditMessageCaptionCounter  uint64
	beforeEditMessageCaptionCounter uint64
	EditMessageCaptionMock          mPublisherClientMockEditMessageCaption

	funcGetChatHistoryRemote          func(chatID int64, fromMessageID int64, offset int32, limit int32) (mp1 *tdlib.Messages, err error)
	inspectFuncGetChatHistoryRemote   func(chatID int64, fromMessageID int64, offset int32, limit int32)
	afterGetChatHistoryRemoteCounter  uint64
	beforeGetChatHistoryRemoteCounter uint64
	GetChatHistoryRemoteMock          mPublisherClientMockGetChatHistoryRemote

	funcGetFavChannelID          func() (i1 int64, err error)
	inspectFuncGetFavChannelID   func()
	afterGetFavChannelIDCounter  uint64
	beforeGetFavChannelIDCounter uint64
	GetFavChannelIDMock          mPublisherClientMockGetFavChannelID

	funcGetPinnedMessageID          func(chatID int64) (i1 int64, err error)
	inspectFuncGetPinnedMessageID   func(chatID int64)
	afterGetPinnedMessageIDCounter  uint64
	beforeGetPinnedMessageIDCounter uint64
	GetPinnedMessageIDMock          mPublisherClientMockGetPinnedMessageID

	funcPinMessage          func(chatID int64, messageID int64) (err error)
	inspectFuncPinMessage   func(chatID int64, messageID int64)
	afterPinMessageCounter  uint64
	beforePinMessageCounter uint64
	PinMessageMock          mPublisherClientMockPinMessage

	funcSendAnimation          func(chatID int64, fileID string, caption string) (i1 int64, err error)
	inspectFuncSendAnimation   func(chatID int64, fileID string, caption string)
	afterSendAnimationCounter  uint64
	beforeSendAnimationCounter uint64
	SendAnimationMock          mPublisherClientMockSendAnimation

	funcSendTextMessage          func(chatID int64, text string) (i1 int64, err error)
	inspectFuncSendTextMessage   func(chatID int64, text string)
	afterSendTextMessageCounter  uint64
	beforeSendTextMessageCounter uint64
	SendTextMessageMock          mPublisherClientMockSendTextMessage
}

// NewPublisherClientMock returns a mock for publisherClient
func NewPublisherClientMock(t minimock.Tester) *PublisherClientMock {
	m := &PublisherClientMock{t: t}
	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.EditMessageCaptionMock = mPublisherClientMockEditMessageCaption{mock: m}
	m.EditMessageCaptionMock.callArgs = []*PublisherClientMockEditMessageCaptionParams{}

	m.GetChatHistoryRemoteMock = mPublisherClientMockGetChatHistoryRemote{mock: m}
	m.GetChatHistoryRemoteMock.callArgs = []*PublisherClientMockGetChatHistoryRemoteParams{}

	m.GetFavChannelIDMock = mPublisherClientMockGetFavChannelID{mock: m}

	m.GetPinnedMessageIDMock = mPublisherClientMockGetPinnedMessageID{mock: m}
	m.GetPinnedMessageIDMock.callArgs = []*PublisherClientMockGetPinnedMessageIDParams{}

	m.PinMessageMock = mPublisherClientMockPinMessage{mock: m}
	m.PinMessageMock.callArgs = []*PublisherClientMockPinMessageParams{}

	m.SendAnimationMock = mPublisherClientMockSendAnimation{mock: m}
	m.SendAnimationMock.callArgs = []*PublisherClientMockSendAnimationParams{}

	m.SendTextMessageMock = mPublisherClientMockSendTextMessage{mock: m}
	m.SendTextMessageMock.callArgs = []*PublisherClientMockSendTextMessageParams{}

	return m
}

type mPublisherClientMockEditMessageCaption struct {
	mock               *PublisherClientMock
	defaultExpectation *PublisherClientMockEditMessageCaptionExpectation
	expectations       []*PublisherClientMockEditMessageCaptionExpectation

	callArgs []*PublisherClientMockEditMessageCaptionParams
	mutex    sync.RWMutex
}

// PublisherClientMockEditMessageCaptionExpectation specifies expectation struct of the publisherClient.EditMessageCaption
type PublisherClientMockEditMessageCaptionExpectation struct {
	mock    *PublisherClientMock
	params  *PublisherClientMockEditMessageCaptionParams
	results *PublisherClientMockEditMessageCaptionResults
	Counter uint64
}

// PublisherClientMockEditMessageCaptionParams contains parameters of the publisherClient.EditMessageCaption
type PublisherClientMockEditMessageCaptionParams struct {
	chatID    int64
	messageID int64
	caption   string
}

// PublisherClientMockEditMessageCaptionResults contains results of the publisherClient.EditMessageCaption
type PublisherClientMockEditMessageCaptionResults struct {
	err error
}

// Expect sets up expected params for publisherClient.EditMessageCaption
func (mmEditMessageCaption *mPublisherClientMockEditMessageCaption) Expect(chatID int64, messageID int64, caption string) *mPublisherClientMockEditMessageCaption {
	if mmEditMessageCaption.mock.funcEditMessageCaption != nil {
		mmEditMessageCaption.mock.t.Fatalf("PublisherClientMock.EditMessageCaption mock is already set by Set")
	}

	if mmEditMessageCaption.defaultExpectation == nil {
		mmEditMessageCaption.defaultExpectation = &PublisherClientMockEditMessageCaptionExpectation{}
	}

	mmEditMessageCaption.defaultExpectation.params = &PublisherClientMockEditMessageCaptionParams{chatID, messageID, caption}
	for _, e := range mmEditMessageCaption.expectations {
		if minimock.Equal(e.params, mmEditMessageCaption.defaultExpectation.params) {
			mmEditMessageCaption.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmEditMessageCaption.defaultExpectation.params)
		}
	}

	return mmEditMessageCaption
}

// Inspect accepts an inspector function that has same arguments as the publisherClient.EditMessageCaption
func (mmEditMessageCaption *mPublisherClientMockEditMessageCaption) Inspect(f func(chatID int64, messageID int64, caption string)) *mPublisherClientMockEditMessageCaption {
	if mmEditMessageCaption.mock.inspectFuncEditMessageCaption != nil {
		mmEditMessageCaption.mock.t.Fatalf("Inspect function is already set for PublisherClientMock.EditMessageCaption")
	}

	mmEditMessageCaption.mock.inspectFuncEditMessageCaption = f

	return mmEditMessageCaption
}

// Return sets up results that will be returned by publisherClient.EditMessageCaption
func (mmEditMessageCaption *mPublisherClientMockEditMessageCaption) Return(err error) *PublisherClientMock {
	if mmEditMessageCaption.mock.funcEditMessageCaption != nil {
		mmEditMessageCaption.mock.t.Fatalf("PublisherClientMock.EditMessageCaption mock is already set by Set")
	}

	if mmEditMessageCaption.defaultExpectation == nil {
		mmEditMessageCaption.defaultExpectation = &PublisherClientMockEditMessageCaptionExpectation{mock: mmEditMessageCaption.mock}
	}
	mmEditMessageCaption.defaultExpectation.results = &PublisherClientMockEditMessageCaptionResults{err}
	return mmEditMessageCaption.mock
}

//Set uses given function f to mock the publisherClient.EditMessageCaption method
func (mmEditMessageCaption *mPublisherClientMockEditMessageCaption) Set(f func(chatID int64, messageID int64, caption string) (err error)) *PublisherClientMock {
	if mmEditMessageCaption.defaultExpectation != nil {
		mmEditMessageCaption.mock.t.Fatalf("Default expectation is already set for the publisherClient.EditMessageCaption method")
	}

	if len(mmEditMessageCaption.expectations) > 0 {
		mmEditMessageCaption.mock.t.Fatalf("Some expectations are already set for the publisherClient.EditMessageCaption method")
	}

	mmEditMessageCaption.mock.funcEditMessageCaption = f
	return mmEditMessageCaption.mock
}

// When sets expectation for the publisherClient.EditMessageCaption which will trigger the result defined by the following
// Then helper
func (mmEditMessageCaption *mPublisherClientMockEditMessageCaption) When(chatID int64, messageID int64, caption string) *PublisherClientMockEditMessageCaptionExpectation {
	if mmEditMessageCaption.mock.funcEditMessageCaption != nil {
		mmEditMessageCaption.mock.t.Fatalf("PublisherClientMock.EditMessageCaption mock is already set by Set")
	}

	expectation := &PublisherClientMockEditMessageCaptionExpectation{
		mock:   mmEditMessageCaption.mock,
		params: &PublisherClientMockEditMessageCaptionParams{chatID, messageID, caption},
	}
	mmEditMessageCaption.expectations = append(mmEditMessageCaption.expectations, expectation)
	return expectation
}

// Then sets up publisherClient.EditMessageCaption return parameters for the expectation previously defined by the When method
func (e *PublisherClientMockEditMessageCaptionExpectation) Then(err error) *PublisherClientMock {
	e.results = &PublisherClientMockEditMessageCaptionResults{err}
	return e.mock
}

// EditMessageCaption implements publisherClient
func (mmEditMessageCaption *PublisherClientMock) EditMessageCaption(chatID int64, messageID int64, caption string) (err error) {
	mm_atomic.AddUint64(&mmEditMessageCaption.beforeEditMessageCaptionCounter, 1)
	defer mm_atomic.AddUint64(&mmEditMessageCaption.afterEditMessageCaptionCounter, 1)

	if mmEditMessageCaption.inspectFuncEditMessageCaption != nil {
		mmEditMessageCaption.inspectFuncEditMessageCaption(chatID, messageID, caption)
	}

	mm_params := &PublisherClientMockEditMessageCaptionParams{chatID, messageID, caption}

	// Record call args
	mmEditMessageCaption.EditMessageCaptionMock.mutex.Lock()
	mmEditMessageCaption.EditMessageCaptionMock.callArgs = append(mmEditMessageCaption.EditMessageCaptionMock.callArgs, mm_params)
	mmEditMessageCaption.EditMessageCaptionMock.mutex.Unlock()

	for _, e := range mmEditMessageCaption.EditMessageCaptionMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmEditMessageCaption.EditMessageCaptionMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmEditMessageCaption.EditMessageCaptionMock.defaultExpectation.Counter, 1)
		mm_want := mmEditMessageCaption.EditMessageCaptionMock.defaultExpectation.params
		mm_got := PublisherClientMockEditMessageCaptionParams{chatID, messageID, caption}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmEditMessageCaption.t.Errorf("PublisherClientMock.EditMessageCaption got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmEditMessageCaption.EditMessageCaptionMock.defaultExpectation.results
		if mm_results == nil {
			mmEditMessageCaption.t.Fatal("No results are set for the PublisherClientMock.EditMessageCaption")
		}
		return (*mm_results).err
	}
	if mmEditMessageCaption.funcEditMessageCaption != nil {
		return mmEditMessageCaption.funcEditMessageCaption(chatID, messageID, caption)
	}
	mmEditMessageCaption.t.Fatalf("Unexpected call to PublisherClientMock.EditMessageCaption. %v %v %v", chatID, messageID, caption)
	return
}

// EditMessageCaptionAfterCounter returns a count of finished PublisherClientMock.EditMessageCaption invocations
func (mmEditMessageCaption *PublisherClientMock) EditMessageCaptionAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmEditMessageCaption.afterEditMessageCaptionCounter)
}

// EditMessageCaptionBeforeCounter returns a count of PublisherClientMock.EditMessageCaption invocations
func (mmEditMessageCaption *PublisherClientMock) EditMessageCaptionBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmEditMessageCaption.beforeEditMessageCaptionCounter)
}

// Calls returns a list of arguments used in each call to PublisherClientMock.EditMessageCaption.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmEditMessageCaption *mPublisherClientMockEditMessageCaption) Calls() []*PublisherClientMockEditMessageCaptionParams {
	mmEditMessageCaption.mutex.RLock()

	argCopy := make([]*PublisherClientMockEditMessageCaptionParams, len(mmEditMessageCaption.callArgs))
	copy(argCopy, mmEditMessageCaption.callArgs)

	mmEditMessageCaption.mutex.RUnlock()

	return argCopy
}

// MinimockEditMessageCaptionDone returns true if the count of the EditMessageCaption invocations corresponds
// the number of defined expectations
func (m *PublisherClientMock) MinimockEditMessageCaptionDone() bool {
	for _, e := range m.EditMessageCaptionMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.EditMessageCaptionMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterEditMessageCaptionCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcEditMessageCaption != nil && mm_atomic.LoadUint64(&m.afterEditMessageCaptionCounter) < 1 {
		return false
	}
	return true
}

// MinimockEditMessageCaptionInspect logs each unmet expectation
func (m *PublisherClientMock) MinimockEditMessageCaptionInspect() {
	for _, e := range m.EditMessageCaptionMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to PublisherClientMock.EditMessageCaption with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.EditMessageCaptionMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterEditMessageCaptionCounter) < 1 {
		if m.EditMessageCaptionMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to PublisherClientMock.EditMessageCaption")
		} else {
			m.t.Errorf("Expected call to PublisherClientMock.EditMessageCaption with params: %#v", *m.EditMessageCaptionMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcEditMessageCaption != nil && mm_atomic.LoadUint64(&m.afterEditMessageCaptionCounter) < 1 {
		m.t.Error("Expected call to PublisherClientMock.EditMessageCaption")
	}
}

type mPublisherClientMockGetChatHistoryRemote struct {
	mock               *PublisherClientMock
	defaultExpectation *PublisherClientMockGetChatHistoryRemoteExpectation
	expectations       []*PublisherClientMockGetChatHistoryRemoteExpectation

	callArgs []*PublisherClientMockGetChatHistoryRemoteParams
	mutex    sync.RWMutex
}

// PublisherClientMockGetChatHistoryRemoteExpectation specifies expectation struct of the publisherClient.GetChatHistoryRemote
type PublisherClientMockGetChatHistoryRemoteExpectation struct {
	mock    *PublisherClientMock
	params  *PublisherClientMockGetChatHistoryRemoteParams
	results *PublisherClientMockGetChatHistoryRemoteResults
	Counter uint64
}

// PublisherClientMockGetChatHistoryRemoteParams contains parameters of the publisherClient.GetChatHistoryRemote
type PublisherClientMockGetChatHistoryRemoteParams struct {
	chatID        int64
	fromMessageID int64
	offset        int32
	limit         int32
}

// PublisherClientMockGetChatHistoryRemoteResults contains results of the publisherClient.GetChatHistoryRemote
type PublisherClientMockGetChatHistoryRemoteResults struct {
	mp1 *tdlib.Messages
	err error
}

// Expect sets up expected params for publisherClient.GetChatHistoryRemote
func (mmGetChatHistoryRemote *mPublisherClientMockGetChatHistoryRemote) Expect(chatID int64, fromMessageID int64, offset int32, limit int32) *mPublisherClientMockGetChatHistoryRemote {
	if mmGetChatHistoryRemote.mock.funcGetChatHistoryRemote != nil {
		mmGetChatHistoryRemote.mock.t.Fatalf("PublisherClientMock.GetChatHistoryRemote mock is already set by Set")
	}

	if mmGetChatHistoryRemote.defaultExpectation == nil {
		mmGetChatHistoryRemote.defaultExpectation = &PublisherClientMockGetChatHistoryRemoteExpectation{}
	}

	mmGetChatHistoryRemote.defaultExpectation.params = &PublisherClientMockGetChatHistoryRemoteParams{chatID, fromMessageID, offset, limit}
	for _, e := range mmGetChatHistoryRemote.expectations {
		if minimock.Equal(e.params, mmGetChatHistoryRemote.defaultExpectation.params) {
			mmGetChatHistoryRemote.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetChatHistoryRemote.defaultExpectation.params)
		}
	}

	return mmGetChatHistoryRemote
}

// Inspect accepts an inspector function that has same arguments as the publisherClient.GetChatHistoryRemote
func (mmGetChatHistoryRemote *mPublisherClientMockGetChatHistoryRemote) Inspect(f func(chatID int64, fromMessageID int64, offset int32, limit int32)) *mPublisherClientMockGetChatHistoryRemote {
	if mmGetChatHistoryRemote.mock.inspectFuncGetChatHistoryRemote != nil {
		mmGetChatHistoryRemote.mock.t.Fatalf("Inspect function is already set for PublisherClientMock.GetChatHistoryRemote")
	}

	mmGetChatHistoryRemote.mock.inspectFuncGetChatHistoryRemote = f

	return mmGetChatHistoryRemote
}

// Return sets up results that will be returned by publisherClient.GetChatHistoryRemote
func (mmGetChatHistoryRemote *mPublisherClientMockGetChatHistoryRemote) Return(mp1 *tdlib.Messages, err error) *PublisherClientMock {
	if mmGetChatHistoryRemote.mock.funcGetChatHistoryRemote != nil {
		mmGetChatHistoryRemote.mock.t.Fatalf("PublisherClientMock.GetChatHistoryRemote mock is already set by Set")
	}

	if mmGetChatHistoryRemote.defaultExpectation == nil {
		mmGetChatHistoryRemote.defaultExpectation = &PublisherClientMockGetChatHistoryRemoteExpectation{mock: mmGetChatHistoryRemote.mock}
	}
	mmGetChatHistoryRemote.defaultExpectation.results = &PublisherClientMockGetChatHistoryRemoteResults{mp1, err}
	return mmGetChatHistoryRemote.mock
}

//Set uses given function f to mock the publisherClient.GetChatHistoryRemote method
func (mmGetChatHistoryRemote *mPublisherClientMockGetChatHistoryRemote) Set(f func(chatID int64, fromMessageID int64, offset int32, limit int32) (mp1 *tdlib.Messages, err error)) *PublisherClientMock {
	if mmGetChatHistoryRemote.defaultExpectation != nil {
		mmGetChatHistoryRemote.mock.t.Fatalf("Default expectation is already set for the publisherClient.GetChatHistoryRemote method")
	}

	if len(mmGetChatHistoryRemote.expectations) > 0 {
		mmGetChatHistoryRemote.mock.t.Fatalf("Some expectations are already set for the publisherClient.GetChatHistoryRemote method")
	}

	mmGetChatHistoryRemote.mock.funcGetChatHistoryRemote = f
	return mmGetChatHistoryRemote.mock
}

// When sets expectation for the publisherClient.GetChatHistoryRemote which will trigger the result defined by the following
// Then helper
func (mmGetChatHistoryRemote *mPublisherClientMockGetChatHistoryRemote) When(chatID int64, fromMessageID int64, offset int32, limit int32) *PublisherClientMockGetChatHistoryRemoteExpectation {
	if mmGetChatHistoryRemote.mock.funcGetChatHistoryRemote != nil {
		mmGetChatHistoryRemote.mock.t.Fatalf("PublisherClientMock.GetChatHistoryRemote mock is already set by Set")
	}

	expectation := &PublisherClientMockGetChatHistoryRemoteExpectation{
		mock:   mmGetChatHistoryRemote.mock,
		params: &PublisherClientMockGetChatHistoryRemoteParams{chatID, fromMessageID, offset, limit},
	}
	mmGetChatHistoryRemote.expectations = append(mmGetChatHistoryRemote.expectations, expectation)
	return expectation
}

// Then sets up publisherClient.GetChatHistoryRemote return parameters for the expectation previously defined by the When method
func (e *PublisherClientMockGetChatHistoryRemoteExpectation) Then(mp1 *tdlib.Messages, err error) *PublisherClientMock {
	e.results = &PublisherClientMockGetChatHistoryRemoteResults{mp1, err}
	return e.mock
}

// GetChatHistoryRemote implements publisherClient
func (mmGetChatHistoryRemote *PublisherClientMock) GetChatHistoryRemote(chatID int64, fromMessageID int64, offset int32, limit int32) (mp1 *tdlib.Messages, err error) {
	mm_atomic.AddUint64(&mmGetChatHistoryRemote.beforeGetChatHistoryRemoteCounter, 1)
	defer mm_atomic.AddUint64(&mmGetChatHistoryRemote.afterGetChatHistoryRemoteCounter, 1)

	if mmGetChatHistoryRemote.inspectFuncGetChatHistoryRemote != nil {
		mmGetChatHistoryRemote.inspectFuncGetChatHistoryRemote(chatID, fromMessageID, offset, limit)
	}

	mm_params := &PublisherClientMockGetChatHistoryRemoteParams{chatID, fromMessageID, offset, limit}

	// Record call args
	mmGetChatHistoryRemote.GetChatHistoryRemoteMock.mutex.Lock()
	mmGetChatHistoryRemote.GetChatHistoryRemoteMock.callArgs = append(mmGetChatHistoryRemote.GetChatHistoryRemoteMock.callArgs, mm_params)
	mmGetChatHistoryRemote.GetChatHistoryRemoteMock.mutex.Unlock()

	for _, e := range mmGetChatHistoryRemote.GetChatHistoryRemoteMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.mp1, e.results.err
		}
	}

	if mmGetChatHistoryRemote.GetChatHistoryRemoteMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetChatHistoryRemote.GetChatHistoryRemoteMock.defaultExpectation.Counter, 1)
		mm_want := mmGetChatHistoryRemote.GetChatHistoryRemoteMock.defaultExpectation.params
		mm_got := PublisherClientMockGetChatHistoryRemoteParams{chatID, fromMessageID, offset, limit}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetChatHistoryRemote.t.Errorf("PublisherClientMock.GetChatHistoryRemote got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetChatHistoryRemote.GetChatHistoryRemoteMock.defaultExpectation.results
		if mm_results == nil {
			mmGetChatHistoryRemote.t.Fatal("No results are set for the PublisherClientMock.GetChatHistoryRemote")
		}
		return (*mm_results).mp1, (*mm_results).err
	}
	if mmGetChatHistoryRemote.funcGetChatHistoryRemote != nil {
		return mmGetChatHistoryRemote.funcGetChatHistoryRemote(chatID, fromMessageID, offset, limit)
	}
	mmGetChatHistoryRemote.t.Fatalf("Unexpected call to PublisherClientMock.GetChatHistoryRemote. %v %v %v %v", chatID, fromMessageID, offset, limit)
	return
}

// GetChatHistoryRemoteAfterCounter returns a count of finished PublisherClientMock.GetChatHistoryRemote invocations
func (mmGetChatHistoryRemote *PublisherClientMock) GetChatHistoryRemoteAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetChatHistoryRemote.afterGetChatHistoryRemoteCounter)
}

// GetChatHistoryRemoteBeforeCounter returns a count of PublisherClientMock.GetChatHistoryRemote invocations
func (mmGetChatHistoryRemote *PublisherClientMock) GetChatHistoryRemoteBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetChatHistoryRemote.beforeGetChatHistoryRemoteCounter)
}

// Calls returns a list of arguments used in each call to PublisherClientMock.GetChatHistoryRemote.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetChatHistoryRemote *mPublisherClientMockGetChatHistoryRemote) Calls() []*PublisherClientMockGetChatHistoryRemoteParams {
	mmGetChatHistoryRemote.mutex.RLock()

	argCopy := make([]*PublisherClientMockGetChatHistoryRemoteParams, len(mmGetChatHistoryRemote.callArgs))
	copy(argCopy, mmGetChatHistoryRemote.callArgs)

	mmGetChatHistoryRemote.mutex.RUnlock()

	return argCopy
}

// MinimockGetChatHistoryRemoteDone returns true if the count of the GetChatHistoryRemote invocations corresponds
// the number of defined expectations
func (m *PublisherClientMock) MinimockGetChatHistoryRemoteDone() bool {
	for _, e := range m.GetChatHistoryRemoteMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetChatHistoryRemoteMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetChatHistoryRemoteCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetChatHistoryRemote != nil && mm_atomic.LoadUint64(&m.afterGetChatHistoryRemoteCounter) < 1 {
		return false
	}
	return true
}

// MinimockGetChatHistoryRemoteInspect logs each unmet expectation
func (m *PublisherClientMock) MinimockGetChatHistoryRemoteInspect() {
	for _, e := range m.GetChatHistoryRemoteMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to PublisherClientMock.GetChatHistoryRemote with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetChatHistoryRemoteMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetChatHistoryRemoteCounter) < 1 {
		if m.GetChatHistoryRemoteMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to PublisherClientMock.GetChatHistoryRemote")
		} else {
			m.t.Errorf("Expected call to PublisherClientMock.GetChatHistoryRemote with params: %#v", *m.GetChatHistoryRemoteMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetChatHistoryRemote != nil && mm_atomic.LoadUint64(&m.afterGetChatHistoryRemoteCounter) < 1 {
		m.t.Error("Expected call to PublisherClientMock.GetChatHistoryRemote")
	}
}

type mPublisherClientMockGetFavChannelID struct {
	mock               *PublisherClientMock
	defaultExpectation *PublisherClientMockGetFavChannelIDExpectation
	expectations       []*PublisherClientMockGetFavChannelIDExpectation
}

// PublisherClientMockGetFavChannelIDExpectation specifies expectation struct of the publisherClient.GetFavChannelID
type PublisherClientMockGetFavChannelIDExpectation struct {
	mock *PublisherClientMock

	results *PublisherClientMockGetFavChannelIDResults
	Counter uint64
}

// PublisherClientMockGetFavChannelIDResults contains results of the publisherClient.GetFavChannelID
type PublisherClientMockGetFavChannelIDResults struct {
	i1  int64
	err error
}

// Expect sets up expected params for publisherClient.GetFavChannelID
func (mmGetFavChannelID *mPublisherClientMockGetFavChannelID) Expect() *mPublisherClientMockGetFavChannelID {
	if mmGetFavChannelID.mock.funcGetFavChannelID != nil {
		mmGetFavChannelID.mock.t.Fatalf("PublisherClientMock.GetFavChannelID mock is already set by Set")
	}

	if mmGetFavChannelID.defaultExpectation == nil {
		mmGetFavChannelID.defaultExpectation = &PublisherClientMockGetFavChannelIDExpectation{}
	}

	return mmGetFavChannelID
}

// Inspect accepts an inspector function that has same arguments as the publisherClient.GetFavChannelID
func (mmGetFavChannelID *mPublisherClientMockGetFavChannelID) Inspect(f func()) *mPublisherClientMockGetFavChannelID {
	if mmGetFavChannelID.mock.inspectFuncGetFavChannelID != nil {
		mmGetFavChannelID.mock.t.Fatalf("Inspect function is already set for PublisherClientMock.GetFavChannelID")
	}

	mmGetFavChannelID.mock.inspectFuncGetFavChannelID = f

	return mmGetFavChannelID
}

// Return sets up results that will be returned by publisherClient.GetFavChannelID
func (mmGetFavChannelID *mPublisherClientMockGetFavChannelID) Return(i1 int64, err error) *PublisherClientMock {
	if mmGetFavChannelID.mock.funcGetFavChannelID != nil {
		mmGetFavChannelID.mock.t.Fatalf("PublisherClientMock.GetFavChannelID mock is already set by Set")
	}

	if mmGetFavChannelID.defaultExpectation == nil {
		mmGetFavChannelID.defaultExpectation = &PublisherClientMockGetFavChannelIDExpectation{mock: mmGetFavChannelID.mock}
	}
	mmGetFavChannelID.defaultExpectation.results = &PublisherClientMockGetFavChannelIDResults{i1, err}
	return mmGetFavChannelID.mock
}

//Set uses given function f to mock the publisherClient.GetFavChannelID method
func (mmGetFavChannelID *mPublisherClientMockGetFavChannelID) Set(f func() (i1 int64, err error)) *PublisherClientMock {
	if mmGetFavChannelID.defaultExpectation != nil {
		mmGetFavChannelID.mock.t.Fatalf("Default expectation is already set for the publisherClient.GetFavChannelID method")
	}

	if len(mmGetFavChannelID.expectations) > 0 {
		mmGetFavChannelID.mock.t.Fatalf("Some expectations are already set for the publisherClient.GetFavChannelID method")
	}

	mmGetFavChannelID.mock.funcGetFavChannelID = f
	return mmGetFavChannelID.mock
}

// GetFavChannelID implements publisherClient
func (mmGetFavChannelID *PublisherClientMock) GetFavChannelID() (i1 int64, err error) {
	mm_atomic.AddUint64(&mmGetFavChannelID.beforeGetFavChannelIDCounter, 1)
	defer mm_atomic.AddUint64(&mmGetFavChannelID.afterGetFavChannelIDCounter, 1)

	if mmGetFavChannelID.inspectFuncGetFavChannelID != nil {
		mmGetFavChannelID.inspectFuncGetFavChannelID()
	}

	if mmGetFavChannelID.GetFavChannelIDMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetFavChannelID.GetFavChannelIDMock.defaultExpectation.Counter, 1)

		mm_results := mmGetFavChannelID.GetFavChannelIDMock.defaultExpectation.results
		if mm_results == nil {
			mmGetFavChannelID.t.Fatal("No results are set for the PublisherClientMock.GetFavChannelID")
		}
		return (*mm_results).i1, (*mm_results).err
	}
	if mmGetFavChannelID.funcGetFavChannelID != nil {
		return mmGetFavChannelID.funcGetFavChannelID()
	}
	mmGetFavChannelID.t.Fatalf("Unexpected call to PublisherClientMock.GetFavChannelID.")
	return
}

// GetFavChannelIDAfterCounter returns a count of finished PublisherClientMock.GetFavChannelID invocations
func (mmGetFavChannelID *PublisherClientMock) GetFavChannelIDAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetFavChannelID.afterGetFavChannelIDCounter)
}

// GetFavChannelIDBeforeCounter returns a count of PublisherClientMock.GetFavChannelID invocations
func (mmGetFavChannelID *PublisherClientMock) GetFavChannelIDBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetFavChannelID.beforeGetFavChannelIDCounter)
}

// MinimockGetFavChannelIDDone returns true if the count of the GetFavChannelID invocations corresponds
// the number of defined expectations
func (m *PublisherClientMock) MinimockGetFavChannelIDDone() bool {
	for _, e := range m.GetFavChannelIDMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetFavChannelIDMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetFavChannelIDCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetFavChannelID != nil && mm_atomic.LoadUint64(&m.afterGetFavChannelIDCounter) < 1 {
		return false
	}
	return true
}

// MinimockGetFavChannelIDInspect logs each unmet expectation
func (m *PublisherClientMock) MinimockGetFavChannelIDInspect() {
	for _, e := range m.GetFavChannelIDMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to PublisherClientMock.GetFavChannelID")
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetFavChannelIDMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetFavChannelIDCounter) < 1 {
		m.t.Error("Expected call to PublisherClientMock.GetFavChannelID")
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetFavChannelID != nil && mm_atomic.LoadUint64(&m.afterGetFavChannelIDCounter) < 1 {
		m.t.Error("Expected call to PublisherClientMock.GetFavChannelID")
	}
}

type mPublisherClientMockGetPinnedMessageID struct {
	mock               *PublisherClientMock
	defaultExpectation *PublisherClientMockGetPinnedMessageIDExpectation
	expectations       []*PublisherClientMockGetPinnedMessageIDExpectation

	callArgs []*PublisherClientMockGetPinnedMessageIDParams
	mutex    sync.RWMutex
}

// PublisherClientMockGetPinnedMessageIDExpectation specifies expectation struct of the publisherClient.GetPinnedMessageID
type PublisherClientMockGetPinnedMessageIDExpectation struct {
	mock    *PublisherClientMock
	params  *PublisherClientMockGetPinnedMessageIDParams
	results *PublisherClientMockGetPinnedMessageIDResults
	Counter uint64
}

// PublisherClientMockGetPinnedMessageIDParams contains parameters of the publisherClient.GetPinnedMessageID
type PublisherClientMockGetPinnedMessageIDParams struct {
	chatID int64
}

// PublisherClientMockGetPinnedMessageIDResults contains results of the publisherClient.GetPinnedMessageID
type PublisherClientMockGetPinnedMessageIDResults struct {
	i1  int64
	err error
}

// Expect sets up expected params for publisherClient.GetPinnedMessageID
func (mmGetPinnedMessageID *mPublisherClientMockGetPinnedMessageID) Expect(chatID int64) *mPublisherClientMockGetPinnedMessageID {
	if mmGetPinnedMessageID.mock.funcGetPinnedMessageID != nil {
		mmGetPinnedMessageID.mock.t.Fatalf("PublisherClientMock.GetPinnedMessageID mock is already set by Set")
	}

	if mmGetPinnedMessageID.defaultExpectation == nil {
		mmGetPinnedMessageID.defaultExpectation = &PublisherClientMockGetPinnedMessageIDExpectation{}
	}

	mmGetPinnedMessageID.defaultExpectation.params = &PublisherClientMockGetPinnedMessageIDParams{chatID}
	for _, e := range mmGetPinnedMessageID.expectations {
		if minimock.Equal(e.params, mmGetPinnedMessageID.defaultExpectation.params) {
			mmGetPinnedMessageID.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetPinnedMessageID.defaultExpectation.params)
		}
	}

	return mmGetPinnedMessageID
}

// Inspect accepts an inspector function that has same arguments as the publisherClient.GetPinnedMessageID
func (mmGetPinnedMessageID *mPublisherClientMockGetPinnedMessageID) Inspect(f func(chatID int64)) *mPublisherClientMockGetPinnedMessageID {
	if mmGetPinnedMessageID.mock.inspectFuncGetPinnedMessageID != nil {
		mmGetPinnedMessageID.mock.t.Fatalf("Inspect function is already set for PublisherClientMock.GetPinnedMessageID")
	}

	mmGetPinnedMessageID.mock.inspectFuncGetPinnedMessageID = f

	return mmGetPinnedMessageID
}

// Return sets up results that will be returned by publisherClient.GetPinnedMessageID
func (mmGetPinnedMessageID *mPublisherClientMockGetPinnedMessageID) Return(i1 int64, err error) *PublisherClientMock {
	if mmGetPinnedMessageID.mock.funcGetPinnedMessageID != nil {
		mmGetPinnedMessageID.mock.t.Fatalf("PublisherClientMock.GetPinnedMessageID mock is already set by Set")
	}

	if mmGetPinnedMessageID.defaultExpectation == nil {
		mmGetPinnedMessageID.defaultExpectation = &PublisherClientMockGetPinnedMessageIDExpectation{mock: mmGetPinnedMessageID.mock}
	}
	mmGetPinnedMessageID.defaultExpectation.results = &PublisherClientMockGetPinnedMessageIDResults{i1, err}
	return mmGetPinnedMessageID.mock
}

//Set uses given function f to mock the publisherClient.GetPinnedMessageID method
func (mmGetPinnedMessageID *mPublisherClientMockGetPinnedMessageID) Set(f func(chatID int64) (i1 int64, err error)) *PublisherClientMock {
	if mmGetPinnedMessageID.defaultExpectation != nil {
		mmGetPinnedMessageID.mock.t.Fatalf("Default expectation is already set for the publisherClient.GetPinnedMessageID method")
	}

	if len(mmGetPinnedMessageID.expectations) > 0 {
		mmGetPinnedMessageID.mock.t.Fatalf("Some expectations are already set for the publisherClient.GetPinnedMessageID method")
	}

	mmGetPinnedMessageID.mock.funcGetPinnedMessageID = f
	return mmGetPinnedMessageID.mock
}

// When sets expectation for the publisherClient.GetPinnedMessageID which will trigger the result defined by the following
// Then helper
func (mmGetPinnedMessageID *mPublisherClientMockGetPinnedMessageID) When(chatID int64) *PublisherClientMockGetPinnedMessageIDExpectation {
	if mmGetPinnedMessageID.mock.funcGetPinnedMessageID != nil {
		mmGetPinnedMessageID.mock.t.Fatalf("PublisherClientMock.GetPinnedMessageID mock is already set by Set")
	}

	expectation := &PublisherClientMockGetPinnedMessageIDExpectation{
		mock:   mmGetPinnedMessageID.mock,
		params: &PublisherClientMockGetPinnedMessageIDParams{chatID},
	}
	mmGetPinnedMessageID.expectations = append(mmGetPinnedMessageID.expectations, expectation)
	return expectation
}

// Then sets up publisherClient.GetPinnedMessageID return parameters for the expectation previously defined by the When method
func (e *PublisherClientMockGetPinnedMessageIDExpectation) Then(i1 int64, err error) *PublisherClientMock {
	e.results = &PublisherClientMockGetPinnedMessageIDResults{i1, err}
	return e.mock
}

// GetPinnedMessageID implements publisherClient
func (mmGetPinnedMessageID *PublisherClientMock) GetPinnedMessageID(chatID int64) (i1 int64, err error) {
	mm_atomic.AddUint64(&mmGetPinnedMessageID.beforeGetPinnedMessageIDCounter, 1)
	defer mm_atomic.AddUint64(&mmGetPinnedMessageID.afterGetPinnedMessageIDCounter, 1)

	if mmGetPinnedMessageID.inspectFuncGetPinnedMessageID != nil {
		mmGetPinnedMessageID.inspectFuncGetPinnedMessageID(chatID)
	}

	mm_params := &PublisherClientMockGetPinnedMessageIDParams{chatID}

	// Record call args
	mmGetPinnedMessageID.GetPinnedMessageIDMock.mutex.Lock()
	mmGetPinnedMessageID.GetPinnedMessageIDMock.callArgs = append(mmGetPinnedMessageID.GetPinnedMessageIDMock.callArgs, mm_params)
	mmGetPinnedMessageID.GetPinnedMessageIDMock.mutex.Unlock()

	for _, e := range mmGetPinnedMessageID.GetPinnedMessageIDMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.i1, e.results.err
		}
	}

	if mmGetPinnedMessageID.GetPinnedMessageIDMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetPinnedMessageID.GetPinnedMessageIDMock.defaultExpectation.Counter, 1)
		mm_want := mmGetPinnedMessageID.GetPinnedMessageIDMock.defaultExpectation.params
		mm_got := PublisherClientMockGetPinnedMessageIDParams{chatID}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetPinnedMessageID.t.Errorf("PublisherClientMock.GetPinnedMessageID got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetPinnedMessageID.GetPinnedMessageIDMock.defaultExpectation.results
		if mm_results == nil {
			mmGetPinnedMessageID.t.Fatal("No results are set for the PublisherClientMock.GetPinnedMessageID")
		}
		return (*mm_results).i1, (*mm_results).err
	}
	if mmGetPinnedMessageID.funcGetPinnedMessageID != nil {
		return mmGetPinnedMessageID.funcGetPinnedMessageID(chatID)
	}
	mmGetPinnedMessageID.t.Fatalf("Unexpected call to PublisherClientMock.GetPinnedMessageID. %v", chatID)
	return
}

// GetPinnedMessageIDAfterCounter returns a count of finished PublisherClientMock.GetPinnedMessageID invocations
func (mmGetPinnedMessageID *PublisherClientMock) GetPinnedMessageIDAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetPinnedMessageID.afterGetPinnedMessageIDCounter)
}

// GetPinnedMessageIDBeforeCounter returns a count of PublisherClientMock.GetPinnedMessageID invocations
func (mmGetPinnedMessageID *PublisherClientMock) GetPinnedMessageIDBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetPinnedMessageID.beforeGetPinnedMessageIDCounter)
}

// Calls returns a list of arguments used in each call to PublisherClientMock.GetPinnedMessageID.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetPinnedMessageID *mPublisherClientMockGetPinnedMessageID) Calls() []*PublisherClientMockGetPinnedMessageIDParams {
	mmGetPinnedMessageID.mutex.RLock()

	argCopy := make([]*PublisherClientMockGetPinnedMessageIDParams, len(mmGetPinnedMessageID.callArgs))
	copy(argCopy, mmGetPinnedMessageID.callArgs)

	mmGetPinnedMessageID.mutex.RUnlock()

	return argCopy
}

// MinimockGetPinnedMessageIDDone returns true if the count of the GetPinnedMessageID invocations corresponds
// the number of defined expectations
func (m *PublisherClientMock) MinimockGetPinnedMessageIDDone() bool {
	for _, e := range m.GetPinnedMessageIDMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetPinnedMessageIDMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetPinnedMessageIDCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetPinnedMessageID != nil && mm_atomic.LoadUint64(&m.afterGetPinnedMessageIDCounter) < 1 {
		return false
	}
	return true
}

// MinimockGetPinnedMessageIDInspect logs each unmet expectation
func (m *PublisherClientMock) MinimockGetPinnedMessageIDInspect() {
	for _, e := range m.GetPinnedMessageIDMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to PublisherClientMock.GetPinnedMessageID with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetPinnedMessageIDMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetPinnedMessageIDCounter) < 1 {
		if m.GetPinnedMessageIDMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to PublisherClientMock.GetPinnedMessageID")
		} else {
			m.t.Errorf("Expected call to PublisherClientMock.GetPinnedMessageID with params: %#v", *m.GetPinnedMessageIDMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetPinnedMessageID != nil && mm_atomic.LoadUint64(&m.afterGetPinnedMessageIDCounter) < 1 {
		m.t.Error("Expected call to PublisherClientMock.GetPinnedMessageID")
	}
}

type mPublisherClientMockPinMessage struct {
	mock               *PublisherClientMock
	defaultExpectation *PublisherClientMockPinMessageExpectation
	expectations       []*PublisherClientMockPinMessageExpectation

	callArgs []*PublisherClientMockPinMessageParams
	mutex    sync.RWMutex
}

// PublisherClientMockPinMessageExpectation specifies expectation struct of the publisherClient.PinMessage
type PublisherClientMockPinMessageExpectation struct {
	mock    *PublisherClientMock
	params  *PublisherClientMockPinMessageParams
	results *PublisherClientMockPinMessageResults
	Counter uint64
}

// PublisherClientMockPinMessageParams contains parameters of the publisherClient.PinMessage
type PublisherClientMockPinMessageParams struct {
	chatID    int64
	messageID int64
}

// PublisherClientMockPinMessageResults contains results of the publisherClient.PinMessage
type PublisherClientMockPinMessageResults struct {
	err error
}

// Expect sets up expected params for publisherClient.PinMessage
func (mmPinMessage *mPublisherClientMockPinMessage) Expect(chatID int64, messageID int64) *mPublisherClientMockPinMessage {
	if mmPinMessage.mock.funcPinMessage != nil {
		mmPinMessage.mock.t.Fatalf("PublisherClientMock.PinMessage mock is already set by Set")
	}

	if mmPinMessage.defaultExpectation == nil {
		mmPinMessage.defaultExpectation = &PublisherClientMockPinMessageExpectation{}
	}

	mmPinMessage.defaultExpectation.params = &PublisherClientMockPinMessageParams{chatID, messageID}
	for _, e := range mmPinMessage.expectations {
		if minimock.Equal(e.params, mmPinMessage.defaultExpectation.params) {
			mmPinMessage.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmPinMessage.defaultExpectation.params)
		}
	}

	return mmPinMessage
}

// Inspect accepts an inspector function that has same arguments as the publisherClient.PinMessage
func (mmPinMessage *mPublisherClientMockPinMessage) Inspect(f func(chatID int64, messageID int64)) *mPublisherClientMockPinMessage {
	if mmPinMessage.mock.inspectFuncPinMessage != nil {
		mmPinMessage.mock.t.Fatalf("Inspect function is already set for PublisherClientMock.PinMessage")
	}

	mmPinMessage.mock.inspectFuncPinMessage = f

	return mmPinMessage
}

// Return sets up results that will be returned by publisherClient.PinMessage
func (mmPinMessage *mPublisherClientMockPinMessage) Return(err error) *PublisherClientMock {
	if mmPinMessage.mock.funcPinMessage != nil {
		mmPinMessage.mock.t.Fatalf("PublisherClientMock.PinMessage mock is already set by Set")
	}

	if mmPinMessage.defaultExpectation == nil {
		mmPinMessage.defaultExpectation = &PublisherClientMockPinMessageExpectation{mock: mmPinMessage.mock}
	}
	mmPinMessage.defaultExpectation.results = &PublisherClientMockPinMessageResults{err}
	return mmPinMessage.mock
}

//Set uses given function f to mock the publisherClient.PinMessage method
func (mmPinMessage *mPublisherClientMockPinMessage) Set(f func(chatID int64, messageID int64) (err error)) *PublisherClientMock {
	if mmPinMessage.defaultExpectation != nil {
		mmPinMessage.mock.t.Fatalf("Default expectation is already set for the publisherClient.PinMessage method")
	}

	if len(mmPinMessage.expectations) > 0 {
		mmPinMessage.mock.t.Fatalf("Some expectations are already set for the publisherClient.PinMessage method")
	}

	mmPinMessage.mock.funcPinMessage = f
	return mmPinMessage.mock
}

// When sets expectation for the publisherClient.PinMessage which will trigger the result defined by the following
// Then helper
func (mmPinMessage *mPublisherClientMockPinMessage) When(chatID int64, messageID int64) *PublisherClientMockPinMessageExpectation {
	if mmPinMessage.mock.funcPinMessage != nil {
		mmPinMessage.mock.t.Fatalf("PublisherClientMock.PinMessage mock is already set by Set")
	}

	expectation := &PublisherClientMockPinMessageExpectation{
		mock:   mmPinMessage.mock,
		params: &PublisherClientMockPinMessageParams{chatID, messageID},
	}
	mmPinMessage.expectations = append(mmPinMessage.expectations, expectation)
	return expectation
}

// Then sets up publisherClient.PinMessage return parameters for the expectation previously defined by the When method
func (e *PublisherClientMockPinMessageExpectation) Then(err error) *PublisherClientMock {
	e.results = &PublisherClientMockPinMessageResults{err}
	return e.mock
}

// PinMessage implements publisherClient
func (mmPinMessage *PublisherClientMock) PinMessage(chatID int64, messageID int64) (err error) {
	mm_atomic.AddUint64(&mmPinMessage.beforePinMessageCounter, 1)
	defer mm_atomic.AddUint64(&mmPinMessage.afterPinMessageCounter, 1)

	if mmPinMessage.inspectFuncPinMessage != nil {
		mmPinMessage.inspectFuncPinMessage(chatID, messageID)
	}

	mm_params := &PublisherClientMockPinMessageParams{chatID, messageID}

	// Record call args
	mmPinMessage.PinMessageMock.mutex.Lock()
	mmPinMessage.PinMessageMock.callArgs = append(mmPinMessage.PinMessageMock.callArgs, mm_params)
	mmPinMessage.PinMessageMock.mutex.Unlock()

	for _, e := range mmPinMessage.PinMessageMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmPinMessage.PinMessageMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmPinMessage.PinMessageMock.defaultExpectation.Counter, 1)
		mm_want := mmPinMessage.PinMessageMock.defaultExpectation.params
		mm_got := PublisherClientMockPinMessageParams{chatID, messageID}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmPinMessage.t.Errorf("PublisherClientMock.PinMessage got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmPinMessage.PinMessageMock.defaultExpectation.results
		if mm_results == nil {
			mmPinMessage.t.Fatal("No results are set for the PublisherClientMock.PinMessage")
		}
		return (*mm_results).err
	}
	if mmPinMessage.funcPinMessage != nil {
		return mmPinMessage.funcPinMessage(chatID, messageID)
	}
	mmPinMessage.t.Fatalf("Unexpected call to PublisherClientMock.PinMessage. %v %v", chatID, messageID)
	return
}

// PinMessageAfterCounter returns a count of finished PublisherClientMock.PinMessage invocations
func (mmPinMessage *PublisherClientMock) PinMessageAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmPinMessage.afterPinMessageCounter)
}

// PinMessageBeforeCounter returns a count of PublisherClientMock.PinMessage invocations
func (mmPinMessage *PublisherClientMock) PinMessageBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmPinMessage.beforePinMessageCounter)
}

// Calls returns a list of arguments used in each call to PublisherClientMock.PinMessage.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmPinMessage *mPublisherClientMockPinMessage) Calls() []*PublisherClientMockPinMessageParams {
	mmPinMessage.mutex.RLock()

	argCopy := make([]*PublisherClientMockPinMessageParams, len(mmPinMessage.callArgs))
	copy(argCopy, mmPinMessage.callArgs)

	mmPinMessage.mutex.RUnlock()

	return argCopy
}

// MinimockPinMessageDone returns true if the count of the PinMessage invocations corresponds
// the number of defined expectations
func (m *PublisherClientMock) MinimockPinMessageDone() bool {
	for _, e := range m.PinMessageMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.PinMessageMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterPinMessageCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcPinMessage != nil && mm_atomic.LoadUint64(&m.afterPinMessageCounter) < 1 {
		return false
	}
	return true
}

// MinimockPinMessageInspect logs each unmet expectation
func (m *PublisherClientMock) MinimockPinMessageInspect() {
	for _, e := range m.PinMessageMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to PublisherClientMock.PinMessage with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.PinMessageMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterPinMessageCounter) < 1 {
		if m.PinMessageMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to PublisherClientMock.PinMessage")
		} else {
			m.t.Errorf("Expected call to PublisherClientMock.PinMessage with params: %#v", *m.PinMessageMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcPinMessage != nil && mm_atomic.LoadUint64(&m.afterPinMessageCounter) < 1 {
		m.t.Error("Expected call to PublisherClientMock.PinMessage")
	}
}

type mPublisherClientMockSendAnimation struct {
	mock               *PublisherClientMock
	defaultExpectation *PublisherClientMockSendAnimationExpectation
	expectations       []*PublisherClientMockSendAnimationExpectation

	callArgs []*PublisherClientMockSendAnimationParams
	mutex    sync.RWMutex
}

// PublisherClientMockSendAnimationExpectation specifies expectation struct of the publisherClient.SendAnimation
type PublisherClientMockSendAnimationExpectation struct {
	mock    *PublisherClientMock
	params  *PublisherClientMockSendAnimationParams
	results *PublisherClientMockSendAnimationResults
	Counter uint64
}

// PublisherClientMockSendAnimationParams contains parameters of the publisherClient.SendAnimation
type PublisherClientMockSendAnimationParams struct {
	chatID  int64
	fileID  string
	caption string
}

// PublisherClientMockSendAnimationResults contains results of the publisherClient.SendAnimation
type PublisherClientMockSendAnimationResults struct {
	i1  int64
	err error
}

// Expect sets up expected params for publisherClient.SendAnimation
func (mmSendAnimation *mPublisherClientMockSendAnimation) Expect(chatID int64, fileID string, caption string) *mPublisherClientMockSendAnimation {
	if mmSendAnimation.mock.funcSendAnimation != nil {
		mmSendAnimation.mock.t.Fatalf("PublisherClientMock.SendAnimation mock is already set by Set")
	}

	if mmSendAnimation.defaultExpectation == nil {
		mmSendAnimation.defaultExpectation = &PublisherClientMockSendAnimationExpectation{}
	}

	mmSendAnimation.defaultExpectation.params = &PublisherClientMockSendAnimationParams{chatID, fileID, caption}
	for _, e := range mmSendAnimation.expectations {
		if minimock.Equal(e.params, mmSendAnimation.defaultExpectation.params) {
			mmSendAnimation.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmSendAnimation.defaultExpectation.params)
		}
	}

	return mmSendAnimation
}

// Inspect accepts an inspector function that has same arguments as the publisherClient.SendAnimation
func (mmSendAnimation *mPublisherClientMockSendAnimation) Inspect(f func(chatID int64, fileID string, caption string)) *mPublisherClientMockSendAnimation {
	if mmSendAnimation.mock.inspectFuncSendAnimation != nil {
		mmSendAnimation.mock.t.Fatalf("Inspect function is already set for PublisherClientMock.SendAnimation")
	}

	mmSendAnimation.mock.inspectFuncSendAnimation = f

	return mmSendAnimation
}

// Return sets up results that will be returned by publisherClient.SendAnimation
func (mmSendAnimation *mPublisherClientMockSendAnimation) Return(i1 int64, err error) *PublisherClientMock {
	if mmSendAnimation.mock.funcSendAnimation != nil {
		mmSendAnimation.mock.t.Fatalf("PublisherClientMock.SendAnimation mock is already set by Set")
	}

	if mmSendAnimation.defaultExpectation == nil {
		mmSendAnimation.defaultExpectation = &PublisherClientMockSendAnimationExpectation{mock: mmSendAnimation.mock}
	}
	mmSendAnimation.defaultExpectation.results = &PublisherClientMockSendAnimationResults{i1, err}
	return mmSendAnimation.mock
}

//Set uses given function f to mock the publisherClient.SendAnimation method
func (mmSendAnimation *mPublisherClientMockSendAnimation) Set(f func(chatID int64, fileID string, caption string) (i1 int64, err error)) *PublisherClientMock {
	if mmSendAnimation.defaultExpectation != nil {
		mmSendAnimation.mock.t.Fatalf("Default expectation is already set for the publisherClient.SendAnimation method")
	}

	if len(mmSendAnimation.expectations) > 0 {
		mmSendAnimation.mock.t.Fatalf("Some expectations are already set for the publisherClient.SendAnimation method")
	}

	mmSendAnimation.mock.funcSendAnimation = f
	return mmSendAnimation.mock
}

// When sets expectation for the publisherClient.SendAnimation which will trigger the result defined by the following
// Then helper
func (mmSendAnimation *mPublisherClientMockSendAnimation) When(chatID int64, fileID string, caption string) *PublisherClientMockSendAnimationExpectation {
	if mmSendAnimation.mock.funcSendAnimation != nil {
		mmSendAnimation.mock.t.Fatalf("PublisherClientMock.SendAnimation mock is already set by Set")
	}

	expectation := &PublisherClientMockSendAnimationExpectation{
		mock:   mmSendAnimation.mock,
		params: &PublisherClientMockSendAnimationParams{chatID, fileID, caption},
	}
	mmSendAnimation.expectations = append(mmSendAnimation.expectations, expectation)
	return expectation
}

// Then sets up publisherClient.SendAnimation return parameters for the expectation previously defined by the When method
func (e *PublisherClientMockSendAnimationExpectation) Then(i1 int64, err error) *PublisherClientMock {
	e.results = &PublisherClientMockSendAnimationResults{i1, err}
	return e.mock
}

// SendAnimation implements publisherClient
func (mmSendAnimation *PublisherClientMock) SendAnimation(chatID int64, fileID string, caption string) (i1 int64, err error) {
	mm_atomic.AddUint64(&mmSendAnimation.beforeSendAnimationCounter, 1)
	defer mm_atomic.AddUint64(&mmSendAnimation.afterSendAnimationCounter, 1)

	if mmSendAnimation.inspectFuncSendAnimation != nil {
		mmSendAnimation.inspectFuncSendAnimation(chatID, fileID, caption)
	}

	mm_params := &PublisherClientMockSendAnimationParams{chatID, fileID, caption}

	// Record call args
	mmSendAnimation.SendAnimationMock.mutex.Lock()
	mmSendAnimation.SendAnimationMock.callArgs = append(mmSendAnimation.SendAnimationMock.callArgs, mm_params)
	mmSendAnimation.SendAnimationMock.mutex.Unlock()

	for _, e := range mmSendAnimation.SendAnimationMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.i1, e.results.err
		}
	}

	if mmSendAnimation.SendAnimationMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmSendAnimation.SendAnimationMock.defaultExpectation.Counter, 1)
		mm_want := mmSendAnimation.SendAnimationMock.defaultExpectation.params
		mm_got := PublisherClientMockSendAnimationParams{chatID, fileID, caption}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmSendAnimation.t.Errorf("PublisherClientMock.SendAnimation got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmSendAnimation.SendAnimationMock.defaultExpectation.results
		if mm_results == nil {
			mmSendAnimation.t.Fatal("No results are set for the PublisherClientMock.SendAnimation")
		}
		return (*mm_results).i1, (*mm_results).err
	}
	if mmSendAnimation.funcSendAnimation != nil {
		return mmSendAnimation.funcSendAnimation(chatID, fileID, caption)
	}
	mmSendAnimation.t.Fatalf("Unexpected call to PublisherClientMock.SendAnimation. %v %v %v", chatID, fileID, caption)
	return
}

// SendAnimationAfterCounter returns a count of finished PublisherClientMock.SendAnimation invocations
func (mmSendAnimation *PublisherClientMock) SendAnimationAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSendAnimation.afterSendAnimationCounter)
}

// SendAnimationBeforeCounter returns a count of PublisherClientMock.SendAnimation invocations
func (mmSendAnimation *PublisherClientMock) SendAnimationBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSendAnimation.beforeSendAnimationCounter)
}

// Calls returns a list of arguments used in each call to PublisherClientMock.SendAnimation.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmSendAnimation *mPublisherClientMockSendAnimation) Calls() []*PublisherClientMockSendAnimationParams {
	mmSendAnimation.mutex.RLock()

	argCopy := make([]*PublisherClientMockSendAnimationParams, len(mmSendAnimation.callArgs))
	copy(argCopy, mmSendAnimation.callArgs)

	mmSendAnimation.mutex.RUnlock()

	return argCopy
}

// MinimockSendAnimationDone returns true if the count of the SendAnimation invocations corresponds
// the number of defined expectations
func (m *PublisherClientMock) MinimockSendAnimationDone() bool {
	for _, e := range m.SendAnimationMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.SendAnimationMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterSendAnimationCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcSendAnimation != nil && mm_atomic.LoadUint64(&m.afterSendAnimationCounter) < 1 {
		return false
	}
	return true
}

// MinimockSendAnimationInspect logs each unmet expectation
func (m *PublisherClientMock) MinimockSendAnimationInspect() {
	for _, e := range m.SendAnimationMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to PublisherClientMock.SendAnimation with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.SendAnimationMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterSendAnimationCounter) < 1 {
		if m.SendAnimationMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to PublisherClientMock.SendAnimation")
		} else {
			m.t.Errorf("Expected call to PublisherClientMock.SendAnimation with params: %#v", *m.SendAnimationMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcSendAnimation != nil && mm_atomic.LoadUint64(&m.afterSendAnimationCounter) < 1 {
		m.t.Error("Expected call to PublisherClientMock.SendAnimation")
	}
}

type mPublisherClientMockSendTextMessage struct {
	mock               *PublisherClientMock
	defaultExpectation *PublisherClientMockSendTextMessageExpectation
	expectations       []*PublisherClientMockSendTextMessageExpectation

	callArgs []*PublisherClientMockSendTextMessageParams
	mutex    sync.RWMutex
}

// PublisherClientMockSendTextMessageExpectation specifies expectation struct of the publisherClient.SendTextMessage
type PublisherClientMockSendTextMessageExpectation struct {
	mock    *PublisherClientMock
	params  *PublisherClientMockSendTextMessageParams
	results *PublisherClientMockSendTextMessageResults
	Counter uint64
}

// PublisherClientMockSendTextMessageParams contains parameters of the publisherClient.SendTextMessage
type PublisherClientMockSendTextMessageParams struct {
	chatID int64
	text   string
}

// PublisherClientMockSendTextMessageResults contains results of the publisherClient.SendTextMessage
type PublisherClientMockSendTextMessageResults struct {
	i1  int64
	err error
}

// Expect sets up expected params for publisherClient.SendTextMessage
func (mmSendTextMessage *mPublisherClientMockSendTextMessage) Expect(chatID int64, text string) *mPublisherClientMockSendTextMessage {
	if mmSendTextMessage.mock.funcSendTextMessage != nil {
		mmSendTextMessage.mock.t.Fatalf("PublisherClientMock.SendTextMessage mock is already set by Set")
	}

	if mmSendTextMessage.defaultExpectation == nil {
		mmSendTextMessage.defaultExpectation = &PublisherClientMockSendTextMessageExpectation{}
	}

	mmSendTextMessage.defaultExpectation.params = &PublisherClientMockSendTextMessageParams{chatID, text}
	for _, e := range mmSendTextMessage.expectations {
		if minimock.Equal(e.params, mmSendTextMessage.defaultExpectation.params) {
			mmSendTextMessage.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmSendTextMessage.defaultExpectation.params)
		}
	}

	return mmSendTextMessage
}

// Inspect accepts an inspector function that has same arguments as the publisherClient.SendTextMessage
func (mmSendTextMessage *mPublisherClientMockSendTextMessage) Inspect(f func(chatID int64, text string)) *mPublisherClientMockSendTextMessage {
	if mmSendTextMessage.mock.inspectFuncSendTextMessage != nil {
		mmSendTextMessage.mock.t.Fatalf("Inspect function is already set for PublisherClientMock.SendTextMessage")
	}

	mmSendTextMessage.mock.inspectFuncSendTextMessage = f

	return mmSendTextMessage
}

// Return sets up results that will be returned by publisherClient.SendTextMessage
func (mmSendTextMessage *mPublisherClientMockSendTextMessage) Return(i1 int64, err error) *PublisherClientMock {
	if mmSendTextMessage.mock.funcSendTextMessage != nil {
		mmSendTextMessage.mock.t.Fatalf("PublisherClientMock.SendTextMessage mock is already set by Set")
	}

	if mmSendTextMessage.defaultExpectation == nil {
		mmSendTextMessage.defaultExpectation = &PublisherClientMockSendTextMessageExpectation{mock: mmSendTextMessage.mock}
	}
	mmSendTextMessage.defaultExpectation.results = &PublisherClientMockSendTextMessageResults{i1, err}
	return mmSendTextMessage.mock
}

//Set uses given function f to mock the publisherClient.SendTextMessage method
func (mmSendTextMessage *mPublisherClientMockSendTextMessage) Set(f func(chatID int64, text string) (i1 int64, err error)) *PublisherClientMock {
	if mmSendTextMessage.defaultExpectation != nil {
		mmSendTextMessage.mock.t.Fatalf("Default expectation is already set for the publisherClient.SendTextMessage method")
	}

	if len(mmSendTextMessage.expectations) > 0 {
		mmSendTextMessage.mock.t.Fatalf("Some expectations are already set for the publisherClient.SendTextMessage method")
	}

	mmSendTextMessage.mock.funcSendTextMessage = f
	return mmSendTextMessage.mock
}

// When sets expectation for the publisherClient.SendTextMessage which will trigger the result defined by the following
// Then helper
func (mmSendTextMessage *mPublisherClientMockSendTextMessage) When(chatID int64, text string) *PublisherClientMockSendTextMessageExpectation {
	if mmSendTextMessage.mock.funcSendTextMessage != nil {
		mmSendTextMessage.mock.t.Fatalf("PublisherClientMock.SendTextMessage mock is already set by Set")
	}

	expectation := &PublisherClientMockSendTextMessageExpectation{
		mock:   mmSendTextMessage.mock,
		params: &PublisherClientMockSendTextMessageParams{chatID, text},
	}
	mmSendTextMessage.expectations = append(mmSendTextMessage.expectations, expectation)
	return expectation
}

// Then sets up publisherClient.SendTextMessage return parameters for the expectation previously defined by the When method
func (e *PublisherClientMockSendTextMessageExpectation) Then(i1 int64, err error) *PublisherClientMock {
	e.results = &PublisherClientMockSendTextMessageResults{i1, err}
	return e.mock
}

// SendTextMessage implements publisherClient
func (mmSendTextMessage *PublisherClientMock) SendTextMessage(chatID int64, text string) (i1 int64, err error) {
	mm_atomic.AddUint64(&mmSendTextMessage.beforeSendTextMessageCounter, 1)
	defer mm_atomic.AddUint64(&mmSendTextMessage.afterSendTextMessageCounter, 1)

	if mmSendTextMessage.inspectFuncSendTextMessage != nil {
		mmSendTextMessage.inspectFuncSendTextMessage(chatID, text)
	}

	mm_params := &PublisherClientMockSendTextMessageParams{chatID, text}

	// Record call args
	mmSendTextMessage.SendTextMessageMock.mutex.Lock()
	mmSendTextMessage.SendTextMessageMock.callArgs = append(mmSendTextMessage.SendTextMessageMock.callArgs, mm_params)
	mmSendTextMessage.SendTextMessageMock.mutex.Unlock()

	for _, e := range mmSendTextMessage.SendTextMessageMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.i1, e.results.err
		}
	}

	if mmSendTextMessage.SendTextMessageMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmSendTextMessage.SendTextMessageMock.defaultExpectation.Counter, 1)
		mm_want := mmSendTextMessage.SendTextMessageMock.defaultExpectation.params
		mm_got := PublisherClientMockSendTextMessageParams{chatID, text}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmSendTextMessage.t.Errorf("PublisherClientMock.SendTextMessage got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmSendTextMessage.SendTextMessageMock.defaultExpectation.results
		if mm_results == nil {
			mmSendTextMessage.t.Fatal("No results are set for the PublisherClientMock.SendTextMessage")
		}
		return (*mm_results).i1, (*mm_results).err
	}
	if mmSendTextMessage.funcSendTextMessage != nil {
		return mmSendTextMessage.funcSendTextMessage(chatID, text)
	}
	mmSendTextMessage.t.Fatalf("Unexpected call to PublisherClientMock.SendTextMessage. %v %v", chatID, text)
	return
}

// SendTextMessageAfterCounter returns a count of finished PublisherClientMock.SendTextMessage invocations
func (mmSendTextMessage *PublisherClientMock) SendTextMessageAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSendTextMessage.afterSendTextMessageCounter)
}

// SendTextMessageBeforeCounter returns a count of PublisherClientMock.SendTextMessage invocations
func (mmSendTextMessage *PublisherClientMock) SendTextMessageBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSendTextMessage.beforeSendTextMessageCounter)
}

// Calls returns a list of arguments used in each call to PublisherClientMock.SendTextMessage.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmSendTextMessage *mPublisherClientMockSendTextMessage) Calls() []*PublisherClientMockSendTextMessageParams {
	mmSendTextMessage.mutex.RLock()

	argCopy := make([]*PublisherClientMockSendTextMessageParams, len(mmSendTextMessage.callArgs))
	copy(argCopy, mmSendTextMessage.callArgs)

	mmSendTextMessage.mutex.RUnlock()

	return argCopy
}

// MinimockSendTextMessageDone returns true if the count of the SendTextMessage invocations corresponds
// the number of defined expectations
func (m *PublisherClientMock) MinimockSendTextMessageDone() bool {
	for _, e := range m.SendTextMessageMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.SendTextMessageMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterSendTextMessageCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcSendTextMessage != nil && mm_atomic.LoadUint64(&m.afterSendTextMessageCounter) < 1 {
		return false
	}
	return true
}

// MinimockSendTextMessageInspect logs each unmet expectation
func (m *PublisherClientMock) MinimockSendTextMessageInspect() {
	for _, e := range m.SendTextMessageMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to PublisherClientMock.SendTextMessage with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.SendTextMessageMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterSendTextMessageCounter) < 1 {
		if m.SendTextMessageMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to PublisherClientMock.SendTextMessage")
		} else {
			m.t.Errorf("Expected call to PublisherClientMock.SendTextMessage with params: %#v", *m.SendTextMessageMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcSendTextMessage != nil && mm_atomic.LoadUint64(&m.afterSendTextMessageCounter) < 1 {
		m.t.Error("Expected call to PublisherClientMock.SendTextMessage")
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *PublisherClientMock) MinimockFinish() {
	if !m.minimockDone() {
		m.MinimockEditMessageCaptionInspect()

		m.MinimockGetChatHistoryRemoteInspect()

		m.MinimockGetFavChannelIDInspect()

		m.MinimockGetPinnedMessageIDInspect()

		m.MinimockPinMessageInspect()

		m.MinimockSendAnimationInspect()

		m.MinimockSendTextMessageInspect()
		m.t.FailNow()
	}
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *PublisherClientMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *PublisherClientMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockEditMessageCaptionDone() &&
		m.MinimockGetChatHistoryRemoteDone() &&
		m.MinimockGetFavChannelIDDone() &&
		m.MinimockGetPinnedMessageIDDone() &&
		m.MinimockPinMessageDone() &&
		m.MinimockSendAnimationDone() &&
		m.MinimockSendTextMessageDone()
}
